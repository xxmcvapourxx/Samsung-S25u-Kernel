/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.2.0.v202012010850.
* Used org.franca.core 0.13.1.201807231814.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#ifndef V0_COM_QUALCOMM_QTI_LOCATION_LOC_IDL_API_HPP_
#define V0_COM_QUALCOMM_QTI_LOCATION_LOC_IDL_API_HPP_




#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#define HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>

#if defined (HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE)
#undef COMMONAPI_INTERNAL_COMPILATION
#undef HAS_DEFINED_COMMONAPI_INTERNAL_COMPILATION_HERE
#endif

namespace v0 {
namespace com {
namespace qualcomm {
namespace qti {
namespace location {

class LocIdlAPI {
public:
    virtual ~LocIdlAPI() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct IDLGnssReportCbInfoMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_LOC_CB_INFO_UNKNOWN = 0,
            IDL_LOC_CB_INFO_BIT = 1,
            IDL_SV_CB_INFO_BIT = 2,
            IDL_NMEA_CB_INFO_BIT = 4,
            IDL_DATA_CB_INFO_BIT = 8,
            IDL_1HZ_MEAS_CB_INFO_BIT = 16
        };
    
        IDLGnssReportCbInfoMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_LOC_CB_INFO_UNKNOWN)) {}
        IDLGnssReportCbInfoMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_LOC_CB_INFO_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_LOC_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_SV_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_NMEA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_DATA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_1HZ_MEAS_CB_INFO_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssReportCbInfoMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssReportCbInfoMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssReportCbInfoMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssReportCbInfoMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssReportCbInfoMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssReportCbInfoMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_LOC_CB_INFO_UNKNOWN): return "IDL_LOC_CB_INFO_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_LOC_CB_INFO_BIT): return "IDL_LOC_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_SV_CB_INFO_BIT): return "IDL_SV_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_NMEA_CB_INFO_BIT): return "IDL_NMEA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_DATA_CB_INFO_BIT): return "IDL_DATA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_1HZ_MEAS_CB_INFO_BIT): return "IDL_1HZ_MEAS_CB_INFO_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLEngineReportCbMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_ENGINE_LOC_CB_INFO_UNKNOWN = 0,
            IDL_ENGINE_LOCATION_CB_INFO_BIT = 1,
            IDL_ENGINE_SV_CB_INFO_BIT = 2,
            IDL_GNSS_ENGINE_NMEA_CB_INFO_BIT = 4,
            IDL_ENGINE_DATA_CB_INFO_BIT = 8,
            IDL_ENGINE_1HZ_MEAS_CB_INFO_BIT = 16,
            IDL_ENGINE_NMEA_CB_INFO_BIT = 32
        };
    
        IDLEngineReportCbMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_ENGINE_LOC_CB_INFO_UNKNOWN)) {}
        IDLEngineReportCbMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_ENGINE_LOC_CB_INFO_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_ENGINE_LOCATION_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_ENGINE_SV_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_GNSS_ENGINE_NMEA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_ENGINE_DATA_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_ENGINE_1HZ_MEAS_CB_INFO_BIT):
                case static_cast< uint32_t>(Literal::IDL_ENGINE_NMEA_CB_INFO_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLEngineReportCbMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLEngineReportCbMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLEngineReportCbMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLEngineReportCbMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLEngineReportCbMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLEngineReportCbMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_ENGINE_LOC_CB_INFO_UNKNOWN): return "IDL_ENGINE_LOC_CB_INFO_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_ENGINE_LOCATION_CB_INFO_BIT): return "IDL_ENGINE_LOCATION_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_ENGINE_SV_CB_INFO_BIT): return "IDL_ENGINE_SV_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_GNSS_ENGINE_NMEA_CB_INFO_BIT): return "IDL_GNSS_ENGINE_NMEA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_ENGINE_DATA_CB_INFO_BIT): return "IDL_ENGINE_DATA_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_ENGINE_1HZ_MEAS_CB_INFO_BIT): return "IDL_ENGINE_1HZ_MEAS_CB_INFO_BIT";
            case static_cast< uint32_t>(Literal::IDL_ENGINE_NMEA_CB_INFO_BIT): return "IDL_ENGINE_NMEA_CB_INFO_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocationCapabilitiesMask : CommonAPI::Enumeration< uint64_t> {
        enum Literal : uint64_t {
            IDL_CAPS_UNKNOWN = 0,
            IDL_CAPS_TIME_BASED_TRACKING_BIT = 1,
            IDL_CAPS_GNSS_MEAS_BIT = 2
        };
    
        IDLLocationCapabilitiesMask()
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(Literal::IDL_CAPS_UNKNOWN)) {}
        IDLLocationCapabilitiesMask(Literal _literal)
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint64_t>(Literal::IDL_CAPS_UNKNOWN):
                case static_cast< uint64_t>(Literal::IDL_CAPS_TIME_BASED_TRACKING_BIT):
                case static_cast< uint64_t>(Literal::IDL_CAPS_GNSS_MEAS_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocationCapabilitiesMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocationCapabilitiesMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocationCapabilitiesMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocationCapabilitiesMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocationCapabilitiesMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocationCapabilitiesMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint64_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint64_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint64_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint64_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint64_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint64_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint64_t>(Literal::IDL_CAPS_UNKNOWN): return "IDL_CAPS_UNKNOWN";
            case static_cast< uint64_t>(Literal::IDL_CAPS_TIME_BASED_TRACKING_BIT): return "IDL_CAPS_TIME_BASED_TRACKING_BIT";
            case static_cast< uint64_t>(Literal::IDL_CAPS_GNSS_MEAS_BIT): return "IDL_CAPS_GNSS_MEAS_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssSvOptionsMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_GNSS_SV_OPTION_UNKNOWN = 0,
            IDL_HAS_EPHEMER_BIT = 1,
            IDL_HAS_ALMANAC_BIT = 2,
            IDL_USED_IN_FIX_BIT = 4,
            IDL_HAS_CARRIER_FREQ_BIT = 8,
            IDL_HAS_GNSS_SIGNAL_TYPE_BIT = 16,
            IDL_HAS_BASEBAND_CARRIER_TO_NOISE_BIT = 32,
            IDL_HAS_ELEVATION_BIT = 64,
            IDL_HAS_AZIMUTH_BIT = 128
        };
    
        IDLGnssSvOptionsMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_GNSS_SV_OPTION_UNKNOWN)) {}
        IDLGnssSvOptionsMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_OPTION_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_HAS_EPHEMER_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_ALMANAC_BIT):
                case static_cast< uint32_t>(Literal::IDL_USED_IN_FIX_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_CARRIER_FREQ_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_GNSS_SIGNAL_TYPE_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_BASEBAND_CARRIER_TO_NOISE_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_ELEVATION_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_AZIMUTH_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssSvOptionsMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssSvOptionsMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssSvOptionsMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssSvOptionsMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssSvOptionsMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssSvOptionsMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_OPTION_UNKNOWN): return "IDL_GNSS_SV_OPTION_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_HAS_EPHEMER_BIT): return "IDL_HAS_EPHEMER_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_ALMANAC_BIT): return "IDL_HAS_ALMANAC_BIT";
            case static_cast< uint32_t>(Literal::IDL_USED_IN_FIX_BIT): return "IDL_USED_IN_FIX_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_CARRIER_FREQ_BIT): return "IDL_HAS_CARRIER_FREQ_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_GNSS_SIGNAL_TYPE_BIT): return "IDL_HAS_GNSS_SIGNAL_TYPE_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_BASEBAND_CARRIER_TO_NOISE_BIT): return "IDL_HAS_BASEBAND_CARRIER_TO_NOISE_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_ELEVATION_BIT): return "IDL_HAS_ELEVATION_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_AZIMUTH_BIT): return "IDL_HAS_AZIMUTH_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocationFlagsMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_LOC_FLAGS_UNKNOWN = 0,
            IDL_HAS_LAT_LONG_BIT = 1,
            IDL_HAS_ALTITUDE_BIT = 2,
            IDL_HAS_SPEED_BIT = 4,
            IDL_HAS_BEARING_BIT = 8,
            IDL_HAS_ACCURACY_BIT = 16,
            IDL_HAS_VERTICAL_ACCURACY_BIT = 32,
            IDL_HAS_SPEED_ACCURACY_BIT = 64,
            IDL_HAS_BEARING_ACCURACY_BIT = 128,
            IDL_HAS_TIMESTAMP_BIT = 256,
            IDL_HAS_ELAPSED_REAL_TIME_BIT = 512,
            IDL_ELAPSED_REAL_TIME_UNC_BIT = 1024,
            IDL_HAS_TIME_UNC_BIT = 2048,
            IDL_HAS_ELAPSED_PTP_TIME_BIT = 4096
        };
    
        IDLLocationFlagsMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_LOC_FLAGS_UNKNOWN)) {}
        IDLLocationFlagsMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_LOC_FLAGS_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_HAS_LAT_LONG_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_ALTITUDE_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_SPEED_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_BEARING_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_VERTICAL_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_SPEED_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_BEARING_ACCURACY_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_TIMESTAMP_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_ELAPSED_REAL_TIME_BIT):
                case static_cast< uint32_t>(Literal::IDL_ELAPSED_REAL_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_HAS_ELAPSED_PTP_TIME_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocationFlagsMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocationFlagsMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocationFlagsMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocationFlagsMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocationFlagsMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocationFlagsMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_LOC_FLAGS_UNKNOWN): return "IDL_LOC_FLAGS_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_HAS_LAT_LONG_BIT): return "IDL_HAS_LAT_LONG_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_ALTITUDE_BIT): return "IDL_HAS_ALTITUDE_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_SPEED_BIT): return "IDL_HAS_SPEED_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_BEARING_BIT): return "IDL_HAS_BEARING_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_ACCURACY_BIT): return "IDL_HAS_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_VERTICAL_ACCURACY_BIT): return "IDL_HAS_VERTICAL_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_SPEED_ACCURACY_BIT): return "IDL_HAS_SPEED_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_BEARING_ACCURACY_BIT): return "IDL_HAS_BEARING_ACCURACY_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_TIMESTAMP_BIT): return "IDL_HAS_TIMESTAMP_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_ELAPSED_REAL_TIME_BIT): return "IDL_HAS_ELAPSED_REAL_TIME_BIT";
            case static_cast< uint32_t>(Literal::IDL_ELAPSED_REAL_TIME_UNC_BIT): return "IDL_ELAPSED_REAL_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_TIME_UNC_BIT): return "IDL_HAS_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_HAS_ELAPSED_PTP_TIME_BIT): return "IDL_HAS_ELAPSED_PTP_TIME_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocationTechnologyMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_TECH_MASK_UNKNOWN = 0,
            IDL_LOC_TECH_GNSS_BIT = 1,
            IDL_LOC_TECH_CELL_BIT = 2,
            IDL_LOC_TECH_WIFI_BIT = 4,
            IDL_LOC_TECH_SENSORS_BIT = 8,
            IDL_LOC_TECH_REF_LOC_BIT = 16,
            IDL_LOC_INJECTED_COARSE_POS_BIT = 32,
            IDL_LOC_TECH_AFLT_BIT = 64,
            IDL_LOC_TECH_HYBRID_BIT = 128,
            IDL_LOC_TECH_PPE_BIT = 256,
            IDL_LOC_TECH_VEH_BIT = 512,
            IDL_LOC_TECH_VIS_BIT = 1024,
            IDL_LOC_TECH_PROPAGATED_BIT = 2048
        };
    
        IDLLocationTechnologyMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_TECH_MASK_UNKNOWN)) {}
        IDLLocationTechnologyMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_TECH_MASK_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_GNSS_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_CELL_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_WIFI_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_SENSORS_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_REF_LOC_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_INJECTED_COARSE_POS_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_AFLT_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_HYBRID_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_PPE_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_VEH_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_VIS_BIT):
                case static_cast< uint32_t>(Literal::IDL_LOC_TECH_PROPAGATED_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocationTechnologyMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocationTechnologyMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocationTechnologyMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocationTechnologyMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocationTechnologyMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocationTechnologyMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_TECH_MASK_UNKNOWN): return "IDL_TECH_MASK_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_GNSS_BIT): return "IDL_LOC_TECH_GNSS_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_CELL_BIT): return "IDL_LOC_TECH_CELL_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_WIFI_BIT): return "IDL_LOC_TECH_WIFI_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_SENSORS_BIT): return "IDL_LOC_TECH_SENSORS_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_REF_LOC_BIT): return "IDL_LOC_TECH_REF_LOC_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_INJECTED_COARSE_POS_BIT): return "IDL_LOC_INJECTED_COARSE_POS_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_AFLT_BIT): return "IDL_LOC_TECH_AFLT_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_HYBRID_BIT): return "IDL_LOC_TECH_HYBRID_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_PPE_BIT): return "IDL_LOC_TECH_PPE_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_VEH_BIT): return "IDL_LOC_TECH_VEH_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_VIS_BIT): return "IDL_LOC_TECH_VIS_BIT";
            case static_cast< uint32_t>(Literal::IDL_LOC_TECH_PROPAGATED_BIT): return "IDL_LOC_TECH_PROPAGATED_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocationReportNavSolutionMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_NAV_MASK_UNKNOWN = 0,
            IDL_SBAS_CORR_IONO = 1,
            IDL_SBAS_CORR_FAST = 2,
            IDL_SBAS_CORR_LONG = 4,
            IDL_SBAS_INTEGRITY = 8,
            IDL_NAV_CORR_DGNSS = 16,
            IDL_NAV_CORR_RTK = 32,
            IDL_NAV_CORR_PPP = 64,
            IDL_NAV_CORR_RTK_FIX = 128,
            IDL_NAV_CORR_ONLY_SBAS_CORR_SV_USED = 256,
            LRNSM_NAV_CORR_MMF_AIDED = 512
        };
    
        IDLLocationReportNavSolutionMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_NAV_MASK_UNKNOWN)) {}
        IDLLocationReportNavSolutionMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_NAV_MASK_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_SBAS_CORR_IONO):
                case static_cast< uint32_t>(Literal::IDL_SBAS_CORR_FAST):
                case static_cast< uint32_t>(Literal::IDL_SBAS_CORR_LONG):
                case static_cast< uint32_t>(Literal::IDL_SBAS_INTEGRITY):
                case static_cast< uint32_t>(Literal::IDL_NAV_CORR_DGNSS):
                case static_cast< uint32_t>(Literal::IDL_NAV_CORR_RTK):
                case static_cast< uint32_t>(Literal::IDL_NAV_CORR_PPP):
                case static_cast< uint32_t>(Literal::IDL_NAV_CORR_RTK_FIX):
                case static_cast< uint32_t>(Literal::IDL_NAV_CORR_ONLY_SBAS_CORR_SV_USED):
                case static_cast< uint32_t>(Literal::LRNSM_NAV_CORR_MMF_AIDED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocationReportNavSolutionMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocationReportNavSolutionMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocationReportNavSolutionMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocationReportNavSolutionMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocationReportNavSolutionMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocationReportNavSolutionMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_NAV_MASK_UNKNOWN): return "IDL_NAV_MASK_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_SBAS_CORR_IONO): return "IDL_SBAS_CORR_IONO";
            case static_cast< uint32_t>(Literal::IDL_SBAS_CORR_FAST): return "IDL_SBAS_CORR_FAST";
            case static_cast< uint32_t>(Literal::IDL_SBAS_CORR_LONG): return "IDL_SBAS_CORR_LONG";
            case static_cast< uint32_t>(Literal::IDL_SBAS_INTEGRITY): return "IDL_SBAS_INTEGRITY";
            case static_cast< uint32_t>(Literal::IDL_NAV_CORR_DGNSS): return "IDL_NAV_CORR_DGNSS";
            case static_cast< uint32_t>(Literal::IDL_NAV_CORR_RTK): return "IDL_NAV_CORR_RTK";
            case static_cast< uint32_t>(Literal::IDL_NAV_CORR_PPP): return "IDL_NAV_CORR_PPP";
            case static_cast< uint32_t>(Literal::IDL_NAV_CORR_RTK_FIX): return "IDL_NAV_CORR_RTK_FIX";
            case static_cast< uint32_t>(Literal::IDL_NAV_CORR_ONLY_SBAS_CORR_SV_USED): return "IDL_NAV_CORR_ONLY_SBAS_CORR_SV_USED";
            case static_cast< uint32_t>(Literal::LRNSM_NAV_CORR_MMF_AIDED): return "LRNSM_NAV_CORR_MMF_AIDED";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocationReportPosDataMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_POS_DATA_MASK_UNKNOWN = 0,
            IDL_NAV_DATA_LONG_ACCEL = 1,
            IDL_NAV_DATA_LAT_ACCEL = 2,
            IDL_NAV_DATA_VERT_ACCEL = 4,
            IDL_NAV_DATA_YAW_RATE = 8,
            IDL_NAV_DATA_PITCH = 16,
            IDL_NAV_DATA_LONG_ACCEL_UNC = 32,
            IDL_NAV_DATA_LAT_ACCEL_UNC = 64,
            IDL_NAV_DATA_VERT_ACCEL_UNC = 128,
            IDL_NAV_DATA_YAW_RATE_UNC = 256,
            IDL_NAV_DATA_PITCH_UNC = 512,
            IDL_NAV_DATA_PITCH_RATE = 1024,
            IDL_NAV_DATA_PITCH_RATE_UNC = 2048,
            IDL_NAV_DATA_ROLL = 4096,
            IDL_NAV_DATA_ROLL_UNC = 8192,
            IDL_NAV_DATA_ROLL_RATE = 16384,
            IDL_NAV_DATA_ROLL_RATE_UNC = 32768,
            IDL_NAV_DATA_YAW = 65536,
            IDL_NAV_DATA_YAW_UNC = 131072
        };
    
        IDLLocationReportPosDataMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_POS_DATA_MASK_UNKNOWN)) {}
        IDLLocationReportPosDataMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_POS_DATA_MASK_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LONG_ACCEL):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LAT_ACCEL):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_VERT_ACCEL):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW_RATE):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LONG_ACCEL_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LAT_ACCEL_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_VERT_ACCEL_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW_RATE_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH_RATE):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH_RATE_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL_RATE):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL_RATE_UNC):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW):
                case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW_UNC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocationReportPosDataMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocationReportPosDataMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocationReportPosDataMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocationReportPosDataMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocationReportPosDataMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocationReportPosDataMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_POS_DATA_MASK_UNKNOWN): return "IDL_POS_DATA_MASK_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LONG_ACCEL): return "IDL_NAV_DATA_LONG_ACCEL";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LAT_ACCEL): return "IDL_NAV_DATA_LAT_ACCEL";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_VERT_ACCEL): return "IDL_NAV_DATA_VERT_ACCEL";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW_RATE): return "IDL_NAV_DATA_YAW_RATE";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH): return "IDL_NAV_DATA_PITCH";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LONG_ACCEL_UNC): return "IDL_NAV_DATA_LONG_ACCEL_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_LAT_ACCEL_UNC): return "IDL_NAV_DATA_LAT_ACCEL_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_VERT_ACCEL_UNC): return "IDL_NAV_DATA_VERT_ACCEL_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW_RATE_UNC): return "IDL_NAV_DATA_YAW_RATE_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH_UNC): return "IDL_NAV_DATA_PITCH_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH_RATE): return "IDL_NAV_DATA_PITCH_RATE";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_PITCH_RATE_UNC): return "IDL_NAV_DATA_PITCH_RATE_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL): return "IDL_NAV_DATA_ROLL";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL_UNC): return "IDL_NAV_DATA_ROLL_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL_RATE): return "IDL_NAV_DATA_ROLL_RATE";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_ROLL_RATE_UNC): return "IDL_NAV_DATA_ROLL_RATE_UNC";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW): return "IDL_NAV_DATA_YAW";
            case static_cast< uint32_t>(Literal::IDL_NAV_DATA_YAW_UNC): return "IDL_NAV_DATA_YAW_UNC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssSignalTypeMask : CommonAPI::Enumeration< uint64_t> {
        enum Literal : uint64_t {
            IDL_GNSS_SIGNAL_UNKNOWN = 0,
            IDL_GNSS_SIGNAL_GPS_L1CA_BIT = 1,
            IDL_GNSS_SIGNAL_GPS_L1C_BIT = 2,
            IDL_GNSS_SIGNAL_GPS_L2_BIT = 4,
            IDL_GNSS_SIGNAL_GPS_L5_BIT = 8,
            IDL_GNSS_SIGNAL_GLONASS_G1_BIT = 16,
            IDL_GNSS_SIGNAL_GLONASS_G2_BIT = 32,
            IDL_GNSS_SIGNAL_GALILEO_E1_BIT = 64,
            IDL_GNSS_SIGNAL_GALILEO_E5A_BIT = 128,
            IDL_GNSS_SIGNAL_GALILEO_E5B_BIT = 256,
            IDL_GNSS_SIGNAL_BEIDOU_B1_BIT = 512,
            IDL_GNSS_SIGNAL_BEIDOU_B2_BIT = 1024,
            IDL_GNSS_SIGNAL_QZSS_L1CA_BIT = 2048,
            IDL_GNSS_SIGNAL_QZSS_L1S_BIT = 4096,
            IDL_GNSS_SIGNAL_QZSS_L2_BIT = 8192,
            IDL_GNSS_SIGNAL_QZSS_L5_BIT = 16384,
            IDL_GNSS_SIGNAL_SBAS_L1_BIT = 32768,
            IDL_GNSS_SIGNAL_BEIDOU_B1I_BIT = 65536,
            IDL_GNSS_SIGNAL_BEIDOU_B1C_BIT = 131072,
            IDL_GNSS_SIGNAL_BEIDOU_B2I_BIT = 262144,
            IDL_GNSS_SIGNAL_BEIDOU_B2AI_BIT = 524288,
            IDL_GNSS_SIGNAL_NAVIC_L5_BIT = 1048576,
            IDL_GNSS_SIGNAL_BEIDOU_B2AQ_BIT = 2097152,
            IDL_GNSS_SIGNAL_BEIDOU_B2BI_BIT = 4194304,
            IDL_GNSS_SIGNAL_BEIDOU_B2BQ_BIT = 8388608,
            GSTM_NAVIC_L1_BIT = 16777216
        };
    
        IDLGnssSignalTypeMask()
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_UNKNOWN)) {}
        IDLGnssSignalTypeMask(Literal _literal)
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_UNKNOWN):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L1CA_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L1C_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L2_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L5_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GLONASS_G1_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GLONASS_G2_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GALILEO_E1_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GALILEO_E5A_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GALILEO_E5B_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B1_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L1CA_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L1S_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L2_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L5_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_SBAS_L1_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B1I_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B1C_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2I_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2AI_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_NAVIC_L5_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2AQ_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2BI_BIT):
                case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2BQ_BIT):
                case static_cast< uint64_t>(Literal::GSTM_NAVIC_L1_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssSignalTypeMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssSignalTypeMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssSignalTypeMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssSignalTypeMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssSignalTypeMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssSignalTypeMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint64_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint64_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint64_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint64_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint64_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint64_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_UNKNOWN): return "IDL_GNSS_SIGNAL_UNKNOWN";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L1CA_BIT): return "IDL_GNSS_SIGNAL_GPS_L1CA_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L1C_BIT): return "IDL_GNSS_SIGNAL_GPS_L1C_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L2_BIT): return "IDL_GNSS_SIGNAL_GPS_L2_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GPS_L5_BIT): return "IDL_GNSS_SIGNAL_GPS_L5_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GLONASS_G1_BIT): return "IDL_GNSS_SIGNAL_GLONASS_G1_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GLONASS_G2_BIT): return "IDL_GNSS_SIGNAL_GLONASS_G2_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GALILEO_E1_BIT): return "IDL_GNSS_SIGNAL_GALILEO_E1_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GALILEO_E5A_BIT): return "IDL_GNSS_SIGNAL_GALILEO_E5A_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_GALILEO_E5B_BIT): return "IDL_GNSS_SIGNAL_GALILEO_E5B_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B1_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B1_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B2_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L1CA_BIT): return "IDL_GNSS_SIGNAL_QZSS_L1CA_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L1S_BIT): return "IDL_GNSS_SIGNAL_QZSS_L1S_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L2_BIT): return "IDL_GNSS_SIGNAL_QZSS_L2_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_QZSS_L5_BIT): return "IDL_GNSS_SIGNAL_QZSS_L5_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_SBAS_L1_BIT): return "IDL_GNSS_SIGNAL_SBAS_L1_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B1I_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B1I_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B1C_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B1C_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2I_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B2I_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2AI_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B2AI_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_NAVIC_L5_BIT): return "IDL_GNSS_SIGNAL_NAVIC_L5_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2AQ_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B2AQ_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2BI_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B2BI_BIT";
            case static_cast< uint64_t>(Literal::IDL_GNSS_SIGNAL_BEIDOU_B2BQ_BIT): return "IDL_GNSS_SIGNAL_BEIDOU_B2BQ_BIT";
            case static_cast< uint64_t>(Literal::GSTM_NAVIC_L1_BIT): return "GSTM_NAVIC_L1_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocationResponse : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_LOC_RESP_UNKNOWN = 0,
            IDL_LOC_RESP_SUCCESS = 1,
            IDL_LOC_RESP_UNKOWN_FAILURE = 2,
            IDL_LOC_RESP_NOT_SUPPORTED = 3,
            IDL_LOC_RESP_PARAM_INVALID = 4,
            IDL_LOC_RESP_TIMEOUT = 5,
            IDL_LOC_RESP_REQUEST_ALREADY_IN_PROGRESS = 6,
            IDL_LOC_RESP_SYSTEM_NOT_READY = 7,
            IDL_LOC_RESP_EXCLUSIVE_SESSION_IN_PROGRESS = 8
        };
    
        IDLLocationResponse()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_LOC_RESP_UNKNOWN)) {}
        IDLLocationResponse(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_SUCCESS):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_UNKOWN_FAILURE):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_NOT_SUPPORTED):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_PARAM_INVALID):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_TIMEOUT):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_REQUEST_ALREADY_IN_PROGRESS):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_SYSTEM_NOT_READY):
                case static_cast< uint32_t>(Literal::IDL_LOC_RESP_EXCLUSIVE_SESSION_IN_PROGRESS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocationResponse &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocationResponse &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocationResponse &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocationResponse &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocationResponse &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocationResponse &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_UNKNOWN): return "IDL_LOC_RESP_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_SUCCESS): return "IDL_LOC_RESP_SUCCESS";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_UNKOWN_FAILURE): return "IDL_LOC_RESP_UNKOWN_FAILURE";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_NOT_SUPPORTED): return "IDL_LOC_RESP_NOT_SUPPORTED";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_PARAM_INVALID): return "IDL_LOC_RESP_PARAM_INVALID";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_TIMEOUT): return "IDL_LOC_RESP_TIMEOUT";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_REQUEST_ALREADY_IN_PROGRESS): return "IDL_LOC_RESP_REQUEST_ALREADY_IN_PROGRESS";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_SYSTEM_NOT_READY): return "IDL_LOC_RESP_SYSTEM_NOT_READY";
            case static_cast< uint32_t>(Literal::IDL_LOC_RESP_EXCLUSIVE_SESSION_IN_PROGRESS): return "IDL_LOC_RESP_EXCLUSIVE_SESSION_IN_PROGRESS";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssSvType : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_GNSS_SV_TYPE_UNKNOWN = 0,
            IDL_GNSS_SV_TYPE_GPS = 1,
            IDL_GNSS_SV_TYPE_SBAS = 2,
            IDL_GNSS_SV_TYPE_GLONASS = 3,
            IDL_GNSS_SV_TYPE_QZSS = 4,
            IDL_GNSS_SV_TYPE_BEIDOU = 5,
            IDL_GNSS_SV_TYPE_GALILEO = 6,
            IDL_GNSS_SV_TYPE_NAVIC = 7
        };
    
        IDLGnssSvType()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_UNKNOWN)) {}
        IDLGnssSvType(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_GPS):
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_SBAS):
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_GLONASS):
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_QZSS):
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_BEIDOU):
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_GALILEO):
                case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_NAVIC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssSvType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssSvType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssSvType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssSvType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssSvType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssSvType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_UNKNOWN): return "IDL_GNSS_SV_TYPE_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_GPS): return "IDL_GNSS_SV_TYPE_GPS";
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_SBAS): return "IDL_GNSS_SV_TYPE_SBAS";
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_GLONASS): return "IDL_GNSS_SV_TYPE_GLONASS";
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_QZSS): return "IDL_GNSS_SV_TYPE_QZSS";
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_BEIDOU): return "IDL_GNSS_SV_TYPE_BEIDOU";
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_GALILEO): return "IDL_GNSS_SV_TYPE_GALILEO";
            case static_cast< uint32_t>(Literal::IDL_GNSS_SV_TYPE_NAVIC): return "IDL_GNSS_SV_TYPE_NAVIC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLCALocationInfoFlagMask : CommonAPI::Enumeration< uint64_t> {
        enum Literal : uint64_t {
            IDL_LOC_INFO_UNKNOWN = 0,
            IDL_LOC_INFO_ALTITUDE_MEAN_SEA_LEVEL = 1,
            IDL_LOC_INFO_DOP = 2,
            IDL_LOC_INFO_MAGNETIC_DEVIATION = 4,
            IDL_LOC_INFO_HOR_RELIABILITY = 8,
            IDL_LOC_INFO_VER_RELIABILITY = 16,
            IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MAJOR = 32,
            IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MINOR = 64,
            IDL_LOC_INFO_HOR_ACCURACY_ELIP_AZIMUTH = 128,
            IDL_LOC_INFO_GNSS_SV_USED_DATA = 256,
            IDL_LOC_INFO_NAV_SOLUTION_MASK_BIT = 512,
            IDL_LCA_GNSS_LOCATION_INFO_POS_TECH_MASK = 1024,
            IDL_LOC_RESERVED1 = 2048,
            IDL_LOC_INFO_POS_DYNAMICS_DATA = 4096,
            IDL_LOC_INFO_EXT_DOP = 8192,
            IDL_LOC_INFO_NORTH_STD_DEV = 16384,
            IDL_LOC_INFO_EAST_STD_DEV = 32768,
            IDL_LOC_INFO_NORTH_VEL = 65536,
            IDL_LOC_INFO_EAST_VEL = 131072,
            IDL_LOC_INFO_UP_VEL = 262144,
            IDL_LOC_INFO_NORTH_VEL_UNC = 524288,
            IDL_LOC_INFO_EAST_VEL_UNC = 1048576,
            IDL_LOC_INFO_UP_VEL_UNC = 2097152,
            IDL_LOC_INFO_LEAP_SECONDS = 4194304,
            IDL_LOC_RESERVED2 = 8388608,
            IDL_LOC_INFO_NUM_SV_USED_IN_POS = 16777216,
            IDL_LOC_INFO_CALIB_CONFIDENCE_PERCENT = 33554432,
            IDL_LOC_INFO_CALIB_STATUS = 67108864,
            IDL_LOC_INFO_OUTPUT_ENG_TYPE = 134217728,
            IDL_LOC_INFO_OUTPUT_ENG_MASK = 268435456,
            IDL_LOC_INFO_CONFORMITY_INDEX = 536870912,
            IDL_LOC_INFO_LLA_VRP_BASED = 1073741824,
            IDL_LOC_INFO_ENU_VEL_VRP_BASED = 2147483648,
            IDL_LOC_INFO_DR_SOL_STATUS_MASK = 4294967296,
            IDL_LOC_INFO_ALTITUDE_ASSUMED = 8589934592,
            IDL_LOC_INFO_SESSION_STATUS = 17179869184,
            IDL_LOC_INFO_INTEGRITY_RISK_USED = 34359738368,
            IDL_LOC_INFO_PROTECT_ALONG_TRACK = 68719476736,
            IDL_LOC_INFO_PROTECT_CROSS_TRACK = 137438953472,
            IDL_LOC_INFO_PROTECT_VERTICAL = 274877906944,
            IDL_LOC_INFO_DGNSS_STATION_ID = 549755813888,
            IDL_LOC_INFO_GPTP_TIME_BIT = 1099511627776,
            IDL_LOC_INFO_GPTP_TIME_UNC_BIT = 2199023255552,
            IDL_LOC_INFO_BASE_LINE_LENGTH_BIT = 4398046511104,
            IDL_LOC_INFO_AGE_OF_CORRECTION_BIT = 8796093022208,
            IDL_LOC_INFO_CURR_REPORT_RATE_BIT = 17592186044416,
            LREFM_LEAP_SECONDS_UNC_BIT = 35184372088832
        };
    
        IDLLCALocationInfoFlagMask()
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(Literal::IDL_LOC_INFO_UNKNOWN)) {}
        IDLLCALocationInfoFlagMask(Literal _literal)
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_UNKNOWN):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_ALTITUDE_MEAN_SEA_LEVEL):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_DOP):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_MAGNETIC_DEVIATION):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_RELIABILITY):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_VER_RELIABILITY):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MAJOR):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MINOR):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_ACCURACY_ELIP_AZIMUTH):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_GNSS_SV_USED_DATA):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NAV_SOLUTION_MASK_BIT):
                case static_cast< uint64_t>(Literal::IDL_LCA_GNSS_LOCATION_INFO_POS_TECH_MASK):
                case static_cast< uint64_t>(Literal::IDL_LOC_RESERVED1):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_POS_DYNAMICS_DATA):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EXT_DOP):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NORTH_STD_DEV):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EAST_STD_DEV):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NORTH_VEL):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EAST_VEL):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_UP_VEL):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NORTH_VEL_UNC):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EAST_VEL_UNC):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_UP_VEL_UNC):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_LEAP_SECONDS):
                case static_cast< uint64_t>(Literal::IDL_LOC_RESERVED2):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NUM_SV_USED_IN_POS):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CALIB_CONFIDENCE_PERCENT):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CALIB_STATUS):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_OUTPUT_ENG_TYPE):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_OUTPUT_ENG_MASK):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CONFORMITY_INDEX):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_LLA_VRP_BASED):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_ENU_VEL_VRP_BASED):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_DR_SOL_STATUS_MASK):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_ALTITUDE_ASSUMED):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_SESSION_STATUS):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_INTEGRITY_RISK_USED):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_PROTECT_ALONG_TRACK):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_PROTECT_CROSS_TRACK):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_PROTECT_VERTICAL):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_DGNSS_STATION_ID):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_GPTP_TIME_BIT):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_GPTP_TIME_UNC_BIT):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_BASE_LINE_LENGTH_BIT):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_AGE_OF_CORRECTION_BIT):
                case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CURR_REPORT_RATE_BIT):
                case static_cast< uint64_t>(Literal::LREFM_LEAP_SECONDS_UNC_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLCALocationInfoFlagMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLCALocationInfoFlagMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLCALocationInfoFlagMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLCALocationInfoFlagMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLCALocationInfoFlagMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLCALocationInfoFlagMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint64_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint64_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint64_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint64_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint64_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint64_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_UNKNOWN): return "IDL_LOC_INFO_UNKNOWN";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_ALTITUDE_MEAN_SEA_LEVEL): return "IDL_LOC_INFO_ALTITUDE_MEAN_SEA_LEVEL";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_DOP): return "IDL_LOC_INFO_DOP";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_MAGNETIC_DEVIATION): return "IDL_LOC_INFO_MAGNETIC_DEVIATION";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_RELIABILITY): return "IDL_LOC_INFO_HOR_RELIABILITY";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_VER_RELIABILITY): return "IDL_LOC_INFO_VER_RELIABILITY";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MAJOR): return "IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MAJOR";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MINOR): return "IDL_LOC_INFO_HOR_ACCURACY_ELIP_SEMI_MINOR";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_HOR_ACCURACY_ELIP_AZIMUTH): return "IDL_LOC_INFO_HOR_ACCURACY_ELIP_AZIMUTH";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_GNSS_SV_USED_DATA): return "IDL_LOC_INFO_GNSS_SV_USED_DATA";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NAV_SOLUTION_MASK_BIT): return "IDL_LOC_INFO_NAV_SOLUTION_MASK_BIT";
            case static_cast< uint64_t>(Literal::IDL_LCA_GNSS_LOCATION_INFO_POS_TECH_MASK): return "IDL_LCA_GNSS_LOCATION_INFO_POS_TECH_MASK";
            case static_cast< uint64_t>(Literal::IDL_LOC_RESERVED1): return "IDL_LOC_RESERVED1";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_POS_DYNAMICS_DATA): return "IDL_LOC_INFO_POS_DYNAMICS_DATA";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EXT_DOP): return "IDL_LOC_INFO_EXT_DOP";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NORTH_STD_DEV): return "IDL_LOC_INFO_NORTH_STD_DEV";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EAST_STD_DEV): return "IDL_LOC_INFO_EAST_STD_DEV";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NORTH_VEL): return "IDL_LOC_INFO_NORTH_VEL";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EAST_VEL): return "IDL_LOC_INFO_EAST_VEL";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_UP_VEL): return "IDL_LOC_INFO_UP_VEL";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NORTH_VEL_UNC): return "IDL_LOC_INFO_NORTH_VEL_UNC";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_EAST_VEL_UNC): return "IDL_LOC_INFO_EAST_VEL_UNC";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_UP_VEL_UNC): return "IDL_LOC_INFO_UP_VEL_UNC";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_LEAP_SECONDS): return "IDL_LOC_INFO_LEAP_SECONDS";
            case static_cast< uint64_t>(Literal::IDL_LOC_RESERVED2): return "IDL_LOC_RESERVED2";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_NUM_SV_USED_IN_POS): return "IDL_LOC_INFO_NUM_SV_USED_IN_POS";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CALIB_CONFIDENCE_PERCENT): return "IDL_LOC_INFO_CALIB_CONFIDENCE_PERCENT";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CALIB_STATUS): return "IDL_LOC_INFO_CALIB_STATUS";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_OUTPUT_ENG_TYPE): return "IDL_LOC_INFO_OUTPUT_ENG_TYPE";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_OUTPUT_ENG_MASK): return "IDL_LOC_INFO_OUTPUT_ENG_MASK";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CONFORMITY_INDEX): return "IDL_LOC_INFO_CONFORMITY_INDEX";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_LLA_VRP_BASED): return "IDL_LOC_INFO_LLA_VRP_BASED";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_ENU_VEL_VRP_BASED): return "IDL_LOC_INFO_ENU_VEL_VRP_BASED";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_DR_SOL_STATUS_MASK): return "IDL_LOC_INFO_DR_SOL_STATUS_MASK";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_ALTITUDE_ASSUMED): return "IDL_LOC_INFO_ALTITUDE_ASSUMED";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_SESSION_STATUS): return "IDL_LOC_INFO_SESSION_STATUS";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_INTEGRITY_RISK_USED): return "IDL_LOC_INFO_INTEGRITY_RISK_USED";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_PROTECT_ALONG_TRACK): return "IDL_LOC_INFO_PROTECT_ALONG_TRACK";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_PROTECT_CROSS_TRACK): return "IDL_LOC_INFO_PROTECT_CROSS_TRACK";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_PROTECT_VERTICAL): return "IDL_LOC_INFO_PROTECT_VERTICAL";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_DGNSS_STATION_ID): return "IDL_LOC_INFO_DGNSS_STATION_ID";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_GPTP_TIME_BIT): return "IDL_LOC_INFO_GPTP_TIME_BIT";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_GPTP_TIME_UNC_BIT): return "IDL_LOC_INFO_GPTP_TIME_UNC_BIT";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_BASE_LINE_LENGTH_BIT): return "IDL_LOC_INFO_BASE_LINE_LENGTH_BIT";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_AGE_OF_CORRECTION_BIT): return "IDL_LOC_INFO_AGE_OF_CORRECTION_BIT";
            case static_cast< uint64_t>(Literal::IDL_LOC_INFO_CURR_REPORT_RATE_BIT): return "IDL_LOC_INFO_CURR_REPORT_RATE_BIT";
            case static_cast< uint64_t>(Literal::LREFM_LEAP_SECONDS_UNC_BIT): return "LREFM_LEAP_SECONDS_UNC_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocationReliability : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_LOC_RELIABILITY_NOT_SET = 0,
            IDL_LOC_RELIABILITY_VERY_LOW = 1,
            IDL_LOC_RELIABILITY_LOW = 2,
            IDL_LOC_RELIABILITY_MEDIUM = 3,
            IDL_LOC_RELIABILITY_HIGH = 4
        };
    
        IDLLocationReliability()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_NOT_SET)) {}
        IDLLocationReliability(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_NOT_SET):
                case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_VERY_LOW):
                case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_LOW):
                case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_MEDIUM):
                case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_HIGH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocationReliability &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocationReliability &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocationReliability &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocationReliability &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocationReliability &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocationReliability &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_NOT_SET): return "IDL_LOC_RELIABILITY_NOT_SET";
            case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_VERY_LOW): return "IDL_LOC_RELIABILITY_VERY_LOW";
            case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_LOW): return "IDL_LOC_RELIABILITY_LOW";
            case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_MEDIUM): return "IDL_LOC_RELIABILITY_MEDIUM";
            case static_cast< uint32_t>(Literal::IDL_LOC_RELIABILITY_HIGH): return "IDL_LOC_RELIABILITY_HIGH";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssSvSystemEnumType : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            IDL_LOC_SV_SYSTEM_UNKNOWN = 0,
            IDL_LOC_SV_SYSTEM_GPS = 1,
            IDL_LOC_SV_SYSTEM_GAL = 2,
            IDL_LOC_SV_SYSTEM_SBAS = 3,
            IDL_LOC_SV_SYSTEM_GLO = 4,
            IDL_LOC_SV_SYSTEM_BDS = 5,
            IDL_LOC_SV_SYSTEM_QZSS = 6,
            IDL_LOC_SV_SYSTEM_NAVIC = 7
        };
    
        IDLGnssSvSystemEnumType()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_UNKNOWN)) {}
        IDLGnssSvSystemEnumType(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_UNKNOWN):
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_GPS):
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_GAL):
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_SBAS):
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_GLO):
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_BDS):
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_QZSS):
                case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_NAVIC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssSvSystemEnumType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssSvSystemEnumType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssSvSystemEnumType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssSvSystemEnumType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssSvSystemEnumType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssSvSystemEnumType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_UNKNOWN): return "IDL_LOC_SV_SYSTEM_UNKNOWN";
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_GPS): return "IDL_LOC_SV_SYSTEM_GPS";
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_GAL): return "IDL_LOC_SV_SYSTEM_GAL";
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_SBAS): return "IDL_LOC_SV_SYSTEM_SBAS";
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_GLO): return "IDL_LOC_SV_SYSTEM_GLO";
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_BDS): return "IDL_LOC_SV_SYSTEM_BDS";
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_QZSS): return "IDL_LOC_SV_SYSTEM_QZSS";
            case static_cast< uint8_t>(Literal::IDL_LOC_SV_SYSTEM_NAVIC): return "IDL_LOC_SV_SYSTEM_NAVIC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssSystemTimeStructTypeFlags : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_SYS_TIME_WEEK_VALID = 1,
            IDL_SYS_TIME_WEEK_MS_VALID = 2,
            IDL_SYS_CLK_TIME_BIAS_VALID = 4,
            IDL_SYS_CLK_TIME_BIAS_UNC_VALID = 8,
            IDL_SYS_REF_FCOUNT_VALID = 16,
            IDL_SYS_NUM_CLOCK_RESETS_VALID = 32
        };
    
        IDLGnssSystemTimeStructTypeFlags()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_SYS_TIME_WEEK_VALID)) {}
        IDLGnssSystemTimeStructTypeFlags(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_SYS_TIME_WEEK_VALID):
                case static_cast< uint32_t>(Literal::IDL_SYS_TIME_WEEK_MS_VALID):
                case static_cast< uint32_t>(Literal::IDL_SYS_CLK_TIME_BIAS_VALID):
                case static_cast< uint32_t>(Literal::IDL_SYS_CLK_TIME_BIAS_UNC_VALID):
                case static_cast< uint32_t>(Literal::IDL_SYS_REF_FCOUNT_VALID):
                case static_cast< uint32_t>(Literal::IDL_SYS_NUM_CLOCK_RESETS_VALID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssSystemTimeStructTypeFlags &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssSystemTimeStructTypeFlags &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssSystemTimeStructTypeFlags &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssSystemTimeStructTypeFlags &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssSystemTimeStructTypeFlags &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssSystemTimeStructTypeFlags &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_SYS_TIME_WEEK_VALID): return "IDL_SYS_TIME_WEEK_VALID";
            case static_cast< uint32_t>(Literal::IDL_SYS_TIME_WEEK_MS_VALID): return "IDL_SYS_TIME_WEEK_MS_VALID";
            case static_cast< uint32_t>(Literal::IDL_SYS_CLK_TIME_BIAS_VALID): return "IDL_SYS_CLK_TIME_BIAS_VALID";
            case static_cast< uint32_t>(Literal::IDL_SYS_CLK_TIME_BIAS_UNC_VALID): return "IDL_SYS_CLK_TIME_BIAS_UNC_VALID";
            case static_cast< uint32_t>(Literal::IDL_SYS_REF_FCOUNT_VALID): return "IDL_SYS_REF_FCOUNT_VALID";
            case static_cast< uint32_t>(Literal::IDL_SYS_NUM_CLOCK_RESETS_VALID): return "IDL_SYS_NUM_CLOCK_RESETS_VALID";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssGloTimeStructTypeFlags : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_GLO_DAYS_VALID = 1,
            IDL_GLO_MSEC_VALID = 2,
            IDL_GLO_CLK_TIME_BIAS_VALID = 4,
            IDL_GLO_CLK_TIME_BIAS_UNC_VALID = 8,
            IDL_GLO_REF_FCOUNT_VALID = 16,
            IDL_GLO_NUM_CLK_RESETS_VALID = 32,
            IDL_GLO_FOUR_YEAR_VALID = 64
        };
    
        IDLGnssGloTimeStructTypeFlags()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_GLO_DAYS_VALID)) {}
        IDLGnssGloTimeStructTypeFlags(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_GLO_DAYS_VALID):
                case static_cast< uint32_t>(Literal::IDL_GLO_MSEC_VALID):
                case static_cast< uint32_t>(Literal::IDL_GLO_CLK_TIME_BIAS_VALID):
                case static_cast< uint32_t>(Literal::IDL_GLO_CLK_TIME_BIAS_UNC_VALID):
                case static_cast< uint32_t>(Literal::IDL_GLO_REF_FCOUNT_VALID):
                case static_cast< uint32_t>(Literal::IDL_GLO_NUM_CLK_RESETS_VALID):
                case static_cast< uint32_t>(Literal::IDL_GLO_FOUR_YEAR_VALID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssGloTimeStructTypeFlags &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssGloTimeStructTypeFlags &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssGloTimeStructTypeFlags &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssGloTimeStructTypeFlags &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssGloTimeStructTypeFlags &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssGloTimeStructTypeFlags &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_GLO_DAYS_VALID): return "IDL_GLO_DAYS_VALID";
            case static_cast< uint32_t>(Literal::IDL_GLO_MSEC_VALID): return "IDL_GLO_MSEC_VALID";
            case static_cast< uint32_t>(Literal::IDL_GLO_CLK_TIME_BIAS_VALID): return "IDL_GLO_CLK_TIME_BIAS_VALID";
            case static_cast< uint32_t>(Literal::IDL_GLO_CLK_TIME_BIAS_UNC_VALID): return "IDL_GLO_CLK_TIME_BIAS_UNC_VALID";
            case static_cast< uint32_t>(Literal::IDL_GLO_REF_FCOUNT_VALID): return "IDL_GLO_REF_FCOUNT_VALID";
            case static_cast< uint32_t>(Literal::IDL_GLO_NUM_CLK_RESETS_VALID): return "IDL_GLO_NUM_CLK_RESETS_VALID";
            case static_cast< uint32_t>(Literal::IDL_GLO_FOUR_YEAR_VALID): return "IDL_GLO_FOUR_YEAR_VALID";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLDrCalibrationStatusMask : CommonAPI::Enumeration< uint64_t> {
        enum Literal : uint64_t {
            IDL_DR_CALIB_UNKNOWN = 0,
            IDL_DR_ROLL_CALIB_NEEDED = 1,
            IDL_DR_PITCH_CALIB_NEEDED = 2,
            IDL_DR_YAW_CALIB_NEEDED = 4,
            IDL_DR_ODO_CALIB_NEEDED = 8,
            IDL_DR_GYRO_CALIB_NEEDED = 16,
            IDL_DR_TURN_CALIB_LOW = 32,
            IDL_DR_TURN_CALIB_MED = 64,
            IDL_DR_TURN_CALIB_HIGH = 128,
            IDL_DR_LINEAR_ACCEL_CALIB_LOW = 256,
            IDL_DR_LINEAR_ACCEL_CALIB_MED = 512,
            IDL_DR_LINEAR_ACCEL_CALIB_HIGH = 1024,
            IDL_DR_LINEAR_MOTION_CALIB_LOW = 2048,
            IDL_DR_LINEAR_MOTION_CALIB_MED = 4096,
            IDL_DR_LINEAR_MOTION_CALIB_HIGH = 8192,
            IDL_DR_STATIC_CALIB_LOW = 16384,
            IDL_DR_STATIC_CALIB_MED = 32768,
            IDL_DR_STATIC_CALIB_HIGH = 65536
        };
    
        IDLDrCalibrationStatusMask()
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(Literal::IDL_DR_CALIB_UNKNOWN)) {}
        IDLDrCalibrationStatusMask(Literal _literal)
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint64_t>(Literal::IDL_DR_CALIB_UNKNOWN):
                case static_cast< uint64_t>(Literal::IDL_DR_ROLL_CALIB_NEEDED):
                case static_cast< uint64_t>(Literal::IDL_DR_PITCH_CALIB_NEEDED):
                case static_cast< uint64_t>(Literal::IDL_DR_YAW_CALIB_NEEDED):
                case static_cast< uint64_t>(Literal::IDL_DR_ODO_CALIB_NEEDED):
                case static_cast< uint64_t>(Literal::IDL_DR_GYRO_CALIB_NEEDED):
                case static_cast< uint64_t>(Literal::IDL_DR_TURN_CALIB_LOW):
                case static_cast< uint64_t>(Literal::IDL_DR_TURN_CALIB_MED):
                case static_cast< uint64_t>(Literal::IDL_DR_TURN_CALIB_HIGH):
                case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_ACCEL_CALIB_LOW):
                case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_ACCEL_CALIB_MED):
                case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_ACCEL_CALIB_HIGH):
                case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_MOTION_CALIB_LOW):
                case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_MOTION_CALIB_MED):
                case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_MOTION_CALIB_HIGH):
                case static_cast< uint64_t>(Literal::IDL_DR_STATIC_CALIB_LOW):
                case static_cast< uint64_t>(Literal::IDL_DR_STATIC_CALIB_MED):
                case static_cast< uint64_t>(Literal::IDL_DR_STATIC_CALIB_HIGH):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLDrCalibrationStatusMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLDrCalibrationStatusMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLDrCalibrationStatusMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLDrCalibrationStatusMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLDrCalibrationStatusMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLDrCalibrationStatusMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint64_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint64_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint64_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint64_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint64_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint64_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint64_t>(Literal::IDL_DR_CALIB_UNKNOWN): return "IDL_DR_CALIB_UNKNOWN";
            case static_cast< uint64_t>(Literal::IDL_DR_ROLL_CALIB_NEEDED): return "IDL_DR_ROLL_CALIB_NEEDED";
            case static_cast< uint64_t>(Literal::IDL_DR_PITCH_CALIB_NEEDED): return "IDL_DR_PITCH_CALIB_NEEDED";
            case static_cast< uint64_t>(Literal::IDL_DR_YAW_CALIB_NEEDED): return "IDL_DR_YAW_CALIB_NEEDED";
            case static_cast< uint64_t>(Literal::IDL_DR_ODO_CALIB_NEEDED): return "IDL_DR_ODO_CALIB_NEEDED";
            case static_cast< uint64_t>(Literal::IDL_DR_GYRO_CALIB_NEEDED): return "IDL_DR_GYRO_CALIB_NEEDED";
            case static_cast< uint64_t>(Literal::IDL_DR_TURN_CALIB_LOW): return "IDL_DR_TURN_CALIB_LOW";
            case static_cast< uint64_t>(Literal::IDL_DR_TURN_CALIB_MED): return "IDL_DR_TURN_CALIB_MED";
            case static_cast< uint64_t>(Literal::IDL_DR_TURN_CALIB_HIGH): return "IDL_DR_TURN_CALIB_HIGH";
            case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_ACCEL_CALIB_LOW): return "IDL_DR_LINEAR_ACCEL_CALIB_LOW";
            case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_ACCEL_CALIB_MED): return "IDL_DR_LINEAR_ACCEL_CALIB_MED";
            case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_ACCEL_CALIB_HIGH): return "IDL_DR_LINEAR_ACCEL_CALIB_HIGH";
            case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_MOTION_CALIB_LOW): return "IDL_DR_LINEAR_MOTION_CALIB_LOW";
            case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_MOTION_CALIB_MED): return "IDL_DR_LINEAR_MOTION_CALIB_MED";
            case static_cast< uint64_t>(Literal::IDL_DR_LINEAR_MOTION_CALIB_HIGH): return "IDL_DR_LINEAR_MOTION_CALIB_HIGH";
            case static_cast< uint64_t>(Literal::IDL_DR_STATIC_CALIB_LOW): return "IDL_DR_STATIC_CALIB_LOW";
            case static_cast< uint64_t>(Literal::IDL_DR_STATIC_CALIB_MED): return "IDL_DR_STATIC_CALIB_MED";
            case static_cast< uint64_t>(Literal::IDL_DR_STATIC_CALIB_HIGH): return "IDL_DR_STATIC_CALIB_HIGH";
            default: return "UNDEFINED";
            }
        }
    };
    struct IDLLocationReportSvUsedInPosition : CommonAPI::Struct< uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t> {
    
        IDLLocationReportSvUsedInPosition()
        {
            std::get< 0>(values_) = 0ull;
            std::get< 1>(values_) = 0ull;
            std::get< 2>(values_) = 0ull;
            std::get< 3>(values_) = 0ull;
            std::get< 4>(values_) = 0ull;
            std::get< 5>(values_) = 0ull;
        }
        IDLLocationReportSvUsedInPosition(const uint64_t &_gpsSvUsedIdsMask, const uint64_t &_gloSvUsedIdsMask, const uint64_t &_galSvUsedIdsMask, const uint64_t &_bdsSvUsedIdsMask, const uint64_t &_qzssSvUsedIdsMask, const uint64_t &_navicSvUsedIdsMask)
        {
            std::get< 0>(values_) = _gpsSvUsedIdsMask;
            std::get< 1>(values_) = _gloSvUsedIdsMask;
            std::get< 2>(values_) = _galSvUsedIdsMask;
            std::get< 3>(values_) = _bdsSvUsedIdsMask;
            std::get< 4>(values_) = _qzssSvUsedIdsMask;
            std::get< 5>(values_) = _navicSvUsedIdsMask;
        }
        inline const uint64_t &getGpsSvUsedIdsMask() const { return std::get< 0>(values_); }
        inline void setGpsSvUsedIdsMask(const uint64_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint64_t &getGloSvUsedIdsMask() const { return std::get< 1>(values_); }
        inline void setGloSvUsedIdsMask(const uint64_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint64_t &getGalSvUsedIdsMask() const { return std::get< 2>(values_); }
        inline void setGalSvUsedIdsMask(const uint64_t &_value) { std::get< 2>(values_) = _value; }
        inline const uint64_t &getBdsSvUsedIdsMask() const { return std::get< 3>(values_); }
        inline void setBdsSvUsedIdsMask(const uint64_t &_value) { std::get< 3>(values_) = _value; }
        inline const uint64_t &getQzssSvUsedIdsMask() const { return std::get< 4>(values_); }
        inline void setQzssSvUsedIdsMask(const uint64_t &_value) { std::get< 4>(values_) = _value; }
        inline const uint64_t &getNavicSvUsedIdsMask() const { return std::get< 5>(values_); }
        inline void setNavicSvUsedIdsMask(const uint64_t &_value) { std::get< 5>(values_) = _value; }
        inline bool operator==(const IDLLocationReportSvUsedInPosition& _other) const {
        return (getGpsSvUsedIdsMask() == _other.getGpsSvUsedIdsMask() && getGloSvUsedIdsMask() == _other.getGloSvUsedIdsMask() && getGalSvUsedIdsMask() == _other.getGalSvUsedIdsMask() && getBdsSvUsedIdsMask() == _other.getBdsSvUsedIdsMask() && getQzssSvUsedIdsMask() == _other.getQzssSvUsedIdsMask() && getNavicSvUsedIdsMask() == _other.getNavicSvUsedIdsMask());
        }
        inline bool operator!=(const IDLLocationReportSvUsedInPosition &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLGnssMeasUsageInfo : CommonAPI::Struct< uint16_t, uint16_t, uint32_t> {
    
        IDLGnssMeasUsageInfo()
        {
            std::get< 0>(values_) = 0u;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = 0ul;
        }
        IDLGnssMeasUsageInfo(const uint16_t &_gnssConstellation, const uint16_t &_gnssSvId, const uint32_t &_gnssSignalType)
        {
            std::get< 0>(values_) = _gnssConstellation;
            std::get< 1>(values_) = _gnssSvId;
            std::get< 2>(values_) = _gnssSignalType;
        }
        inline const uint16_t &getGnssConstellation() const { return std::get< 0>(values_); }
        inline void setGnssConstellation(const uint16_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint16_t &getGnssSvId() const { return std::get< 1>(values_); }
        inline void setGnssSvId(const uint16_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint32_t &getGnssSignalType() const { return std::get< 2>(values_); }
        inline void setGnssSignalType(const uint32_t &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const IDLGnssMeasUsageInfo& _other) const {
        return (getGnssConstellation() == _other.getGnssConstellation() && getGnssSvId() == _other.getGnssSvId() && getGnssSignalType() == _other.getGnssSignalType());
        }
        inline bool operator!=(const IDLGnssMeasUsageInfo &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLLocationReportPositionDynamics : CommonAPI::Struct< uint32_t, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float> {
    
        IDLLocationReportPositionDynamics()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0.0f;
            std::get< 2>(values_) = 0.0f;
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = 0.0f;
            std::get< 10>(values_) = 0.0f;
            std::get< 11>(values_) = 0.0f;
            std::get< 12>(values_) = 0.0f;
            std::get< 13>(values_) = 0.0f;
            std::get< 14>(values_) = 0.0f;
            std::get< 15>(values_) = 0.0f;
            std::get< 16>(values_) = 0.0f;
            std::get< 17>(values_) = 0.0f;
            std::get< 18>(values_) = 0.0f;
        }
        IDLLocationReportPositionDynamics(const uint32_t &_bodyFrameDataMask, const float &_longAccel, const float &_latAccel, const float &_vertAccel, const float &_longAccelUnc, const float &_latAccelUnc, const float &_vertAccelUnc, const float &_pitch, const float &_pitchUnc, const float &_pitchRate, const float &_pitchRateUnc, const float &_roll, const float &_rollUnc, const float &_rollRate, const float &_rollRateUnc, const float &_yaw, const float &_yawUnc, const float &_yawRate, const float &_yawRateUnc)
        {
            std::get< 0>(values_) = _bodyFrameDataMask;
            std::get< 1>(values_) = _longAccel;
            std::get< 2>(values_) = _latAccel;
            std::get< 3>(values_) = _vertAccel;
            std::get< 4>(values_) = _longAccelUnc;
            std::get< 5>(values_) = _latAccelUnc;
            std::get< 6>(values_) = _vertAccelUnc;
            std::get< 7>(values_) = _pitch;
            std::get< 8>(values_) = _pitchUnc;
            std::get< 9>(values_) = _pitchRate;
            std::get< 10>(values_) = _pitchRateUnc;
            std::get< 11>(values_) = _roll;
            std::get< 12>(values_) = _rollUnc;
            std::get< 13>(values_) = _rollRate;
            std::get< 14>(values_) = _rollRateUnc;
            std::get< 15>(values_) = _yaw;
            std::get< 16>(values_) = _yawUnc;
            std::get< 17>(values_) = _yawRate;
            std::get< 18>(values_) = _yawRateUnc;
        }
        inline const uint32_t &getBodyFrameDataMask() const { return std::get< 0>(values_); }
        inline void setBodyFrameDataMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const float &getLongAccel() const { return std::get< 1>(values_); }
        inline void setLongAccel(const float &_value) { std::get< 1>(values_) = _value; }
        inline const float &getLatAccel() const { return std::get< 2>(values_); }
        inline void setLatAccel(const float &_value) { std::get< 2>(values_) = _value; }
        inline const float &getVertAccel() const { return std::get< 3>(values_); }
        inline void setVertAccel(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getLongAccelUnc() const { return std::get< 4>(values_); }
        inline void setLongAccelUnc(const float &_value) { std::get< 4>(values_) = _value; }
        inline const float &getLatAccelUnc() const { return std::get< 5>(values_); }
        inline void setLatAccelUnc(const float &_value) { std::get< 5>(values_) = _value; }
        inline const float &getVertAccelUnc() const { return std::get< 6>(values_); }
        inline void setVertAccelUnc(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getPitch() const { return std::get< 7>(values_); }
        inline void setPitch(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getPitchUnc() const { return std::get< 8>(values_); }
        inline void setPitchUnc(const float &_value) { std::get< 8>(values_) = _value; }
        inline const float &getPitchRate() const { return std::get< 9>(values_); }
        inline void setPitchRate(const float &_value) { std::get< 9>(values_) = _value; }
        inline const float &getPitchRateUnc() const { return std::get< 10>(values_); }
        inline void setPitchRateUnc(const float &_value) { std::get< 10>(values_) = _value; }
        inline const float &getRoll() const { return std::get< 11>(values_); }
        inline void setRoll(const float &_value) { std::get< 11>(values_) = _value; }
        inline const float &getRollUnc() const { return std::get< 12>(values_); }
        inline void setRollUnc(const float &_value) { std::get< 12>(values_) = _value; }
        inline const float &getRollRate() const { return std::get< 13>(values_); }
        inline void setRollRate(const float &_value) { std::get< 13>(values_) = _value; }
        inline const float &getRollRateUnc() const { return std::get< 14>(values_); }
        inline void setRollRateUnc(const float &_value) { std::get< 14>(values_) = _value; }
        inline const float &getYaw() const { return std::get< 15>(values_); }
        inline void setYaw(const float &_value) { std::get< 15>(values_) = _value; }
        inline const float &getYawUnc() const { return std::get< 16>(values_); }
        inline void setYawUnc(const float &_value) { std::get< 16>(values_) = _value; }
        inline const float &getYawRate() const { return std::get< 17>(values_); }
        inline void setYawRate(const float &_value) { std::get< 17>(values_) = _value; }
        inline const float &getYawRateUnc() const { return std::get< 18>(values_); }
        inline void setYawRateUnc(const float &_value) { std::get< 18>(values_) = _value; }
        inline bool operator==(const IDLLocationReportPositionDynamics& _other) const {
        return (getBodyFrameDataMask() == _other.getBodyFrameDataMask() && getLongAccel() == _other.getLongAccel() && getLatAccel() == _other.getLatAccel() && getVertAccel() == _other.getVertAccel() && getLongAccelUnc() == _other.getLongAccelUnc() && getLatAccelUnc() == _other.getLatAccelUnc() && getVertAccelUnc() == _other.getVertAccelUnc() && getPitch() == _other.getPitch() && getPitchUnc() == _other.getPitchUnc() && getPitchRate() == _other.getPitchRate() && getPitchRateUnc() == _other.getPitchRateUnc() && getRoll() == _other.getRoll() && getRollUnc() == _other.getRollUnc() && getRollRate() == _other.getRollRate() && getRollRateUnc() == _other.getRollRateUnc() && getYaw() == _other.getYaw() && getYawUnc() == _other.getYawUnc() && getYawRate() == _other.getYawRate() && getYawRateUnc() == _other.getYawRateUnc());
        }
        inline bool operator!=(const IDLLocationReportPositionDynamics &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLGnssSystemTimeStructType : CommonAPI::Struct< uint32_t, uint16_t, uint32_t, float, float, uint32_t, uint32_t> {
    
        IDLGnssSystemTimeStructType()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = 0ul;
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0ul;
            std::get< 6>(values_) = 0ul;
        }
        IDLGnssSystemTimeStructType(const uint32_t &_validityMask, const uint16_t &_systemWeek, const uint32_t &_systemMsec, const float &_systemClkTimeBias, const float &_systemClkTimeUncMs, const uint32_t &_refFCount, const uint32_t &_numClockResets)
        {
            std::get< 0>(values_) = _validityMask;
            std::get< 1>(values_) = _systemWeek;
            std::get< 2>(values_) = _systemMsec;
            std::get< 3>(values_) = _systemClkTimeBias;
            std::get< 4>(values_) = _systemClkTimeUncMs;
            std::get< 5>(values_) = _refFCount;
            std::get< 6>(values_) = _numClockResets;
        }
        inline const uint32_t &getValidityMask() const { return std::get< 0>(values_); }
        inline void setValidityMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint16_t &getSystemWeek() const { return std::get< 1>(values_); }
        inline void setSystemWeek(const uint16_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint32_t &getSystemMsec() const { return std::get< 2>(values_); }
        inline void setSystemMsec(const uint32_t &_value) { std::get< 2>(values_) = _value; }
        inline const float &getSystemClkTimeBias() const { return std::get< 3>(values_); }
        inline void setSystemClkTimeBias(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getSystemClkTimeUncMs() const { return std::get< 4>(values_); }
        inline void setSystemClkTimeUncMs(const float &_value) { std::get< 4>(values_) = _value; }
        inline const uint32_t &getRefFCount() const { return std::get< 5>(values_); }
        inline void setRefFCount(const uint32_t &_value) { std::get< 5>(values_) = _value; }
        inline const uint32_t &getNumClockResets() const { return std::get< 6>(values_); }
        inline void setNumClockResets(const uint32_t &_value) { std::get< 6>(values_) = _value; }
        inline bool operator==(const IDLGnssSystemTimeStructType& _other) const {
        return (getValidityMask() == _other.getValidityMask() && getSystemWeek() == _other.getSystemWeek() && getSystemMsec() == _other.getSystemMsec() && getSystemClkTimeBias() == _other.getSystemClkTimeBias() && getSystemClkTimeUncMs() == _other.getSystemClkTimeUncMs() && getRefFCount() == _other.getRefFCount() && getNumClockResets() == _other.getNumClockResets());
        }
        inline bool operator!=(const IDLGnssSystemTimeStructType &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLGnssGloTimeStructType : CommonAPI::Struct< uint32_t, uint8_t, uint16_t, uint32_t, float, float, uint32_t, uint32_t> {
    
        IDLGnssGloTimeStructType()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = 0u;
            std::get< 3>(values_) = 0ul;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0ul;
            std::get< 7>(values_) = 0ul;
        }
        IDLGnssGloTimeStructType(const uint32_t &_validityMask, const uint8_t &_gloFourYear, const uint16_t &_gloDays, const uint32_t &_gloMsec, const float &_gloClkTimeBias, const float &_gloClkTimeUncMs, const uint32_t &_refFCount, const uint32_t &_numClockResets)
        {
            std::get< 0>(values_) = _validityMask;
            std::get< 1>(values_) = _gloFourYear;
            std::get< 2>(values_) = _gloDays;
            std::get< 3>(values_) = _gloMsec;
            std::get< 4>(values_) = _gloClkTimeBias;
            std::get< 5>(values_) = _gloClkTimeUncMs;
            std::get< 6>(values_) = _refFCount;
            std::get< 7>(values_) = _numClockResets;
        }
        inline const uint32_t &getValidityMask() const { return std::get< 0>(values_); }
        inline void setValidityMask(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint8_t &getGloFourYear() const { return std::get< 1>(values_); }
        inline void setGloFourYear(const uint8_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint16_t &getGloDays() const { return std::get< 2>(values_); }
        inline void setGloDays(const uint16_t &_value) { std::get< 2>(values_) = _value; }
        inline const uint32_t &getGloMsec() const { return std::get< 3>(values_); }
        inline void setGloMsec(const uint32_t &_value) { std::get< 3>(values_) = _value; }
        inline const float &getGloClkTimeBias() const { return std::get< 4>(values_); }
        inline void setGloClkTimeBias(const float &_value) { std::get< 4>(values_) = _value; }
        inline const float &getGloClkTimeUncMs() const { return std::get< 5>(values_); }
        inline void setGloClkTimeUncMs(const float &_value) { std::get< 5>(values_) = _value; }
        inline const uint32_t &getRefFCount() const { return std::get< 6>(values_); }
        inline void setRefFCount(const uint32_t &_value) { std::get< 6>(values_) = _value; }
        inline const uint32_t &getNumClockResets() const { return std::get< 7>(values_); }
        inline void setNumClockResets(const uint32_t &_value) { std::get< 7>(values_) = _value; }
        inline bool operator==(const IDLGnssGloTimeStructType& _other) const {
        return (getValidityMask() == _other.getValidityMask() && getGloFourYear() == _other.getGloFourYear() && getGloDays() == _other.getGloDays() && getGloMsec() == _other.getGloMsec() && getGloClkTimeBias() == _other.getGloClkTimeBias() && getGloClkTimeUncMs() == _other.getGloClkTimeUncMs() && getRefFCount() == _other.getRefFCount() && getNumClockResets() == _other.getNumClockResets());
        }
        inline bool operator!=(const IDLGnssGloTimeStructType &_other) const {
            return !((*this) == _other);
        }
    
    };
    typedef CommonAPI::Variant< IDLGnssSystemTimeStructType, IDLGnssSystemTimeStructType, IDLGnssSystemTimeStructType, IDLGnssSystemTimeStructType, IDLGnssGloTimeStructType, IDLGnssSystemTimeStructType>  IDLSystemTimeStructUnion;
    struct IDLGnssSystemTime : CommonAPI::Struct< IDLGnssSvSystemEnumType, IDLSystemTimeStructUnion> {
    
        IDLGnssSystemTime()
        {
            std::get< 0>(values_) = IDLGnssSvSystemEnumType();
            std::get< 1>(values_) = IDLSystemTimeStructUnion();
        }
        IDLGnssSystemTime(const IDLGnssSvSystemEnumType &_gnssSystemTimeSrc, const IDLSystemTimeStructUnion &_timeUnion)
        {
            std::get< 0>(values_) = _gnssSystemTimeSrc;
            std::get< 1>(values_) = _timeUnion;
        }
        inline const IDLGnssSvSystemEnumType &getGnssSystemTimeSrc() const { return std::get< 0>(values_); }
        inline void setGnssSystemTimeSrc(const IDLGnssSvSystemEnumType &_value) { std::get< 0>(values_) = _value; }
        inline const IDLSystemTimeStructUnion &getTimeUnion() const { return std::get< 1>(values_); }
        inline void setTimeUnion(const IDLSystemTimeStructUnion &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const IDLGnssSystemTime& _other) const {
        return (getGnssSystemTimeSrc() == _other.getGnssSystemTimeSrc() && getTimeUnion() == _other.getTimeUnion());
        }
        inline bool operator!=(const IDLGnssSystemTime &_other) const {
            return !((*this) == _other);
        }
    
    };
    
    struct IDLLocReqEngineTypeMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_LOC_REQ_ENG_UNKNOWN = 0,
            IDL_LOC_REQ_ENG_FUSED = 1,
            IDL_LOC_REQ_ENG_SPE = 2,
            IDL_LOC_REQ_ENG_PPE = 4,
            IDL_LOC_REQ_ENG_VPE = 8
        };
    
        IDLLocReqEngineTypeMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_UNKNOWN)) {}
        IDLLocReqEngineTypeMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_FUSED):
                case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_SPE):
                case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_PPE):
                case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_VPE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocReqEngineTypeMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocReqEngineTypeMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocReqEngineTypeMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocReqEngineTypeMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocReqEngineTypeMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocReqEngineTypeMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_UNKNOWN): return "IDL_LOC_REQ_ENG_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_FUSED): return "IDL_LOC_REQ_ENG_FUSED";
            case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_SPE): return "IDL_LOC_REQ_ENG_SPE";
            case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_PPE): return "IDL_LOC_REQ_ENG_PPE";
            case static_cast< uint32_t>(Literal::IDL_LOC_REQ_ENG_VPE): return "IDL_LOC_REQ_ENG_VPE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocOutputEngineType : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_LOC_OUTPUT_ENGINE_UNKNOWN = 0,
            IDL_LOC_OUTPUT_ENGINE_FUSED = 1,
            IDL_LOC_OUTPUT_ENGINE_SPE = 2,
            IDL_LOC_OUTPUT_ENGINE_PPE = 3,
            IDL_LOC_OUTPUT_ENGINE_VPE = 4,
            IDL_LOC_OUTPUT_ENGINE_COUNT = 4
        };
    
        IDLLocOutputEngineType()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_UNKNOWN)) {}
        IDLLocOutputEngineType(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_FUSED):
                case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_SPE):
                case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_PPE):
                case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_VPE):
                //case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_COUNT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocOutputEngineType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocOutputEngineType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocOutputEngineType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocOutputEngineType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocOutputEngineType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocOutputEngineType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_UNKNOWN): return "IDL_LOC_OUTPUT_ENGINE_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_FUSED): return "IDL_LOC_OUTPUT_ENGINE_FUSED";
            case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_SPE): return "IDL_LOC_OUTPUT_ENGINE_SPE";
            case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_PPE): return "IDL_LOC_OUTPUT_ENGINE_PPE";
            case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_VPE): return "IDL_LOC_OUTPUT_ENGINE_VPE";
            //case static_cast< uint32_t>(Literal::IDL_LOC_OUTPUT_ENGINE_COUNT): return "IDL_LOC_OUTPUT_ENGINE_COUNT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLPositioningEngineMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_LOC_POS_ENG_UNKNOWN = 0,
            IDL_STANDARD_POSITIONING_ENGINE = 1,
            IDL_DEAD_RECKONING_ENGINE = 2,
            IDL_PRECISE_POSITIONING_ENGINE = 4,
            IDL_VP_POSITIONING_ENGINE = 8
        };
    
        IDLPositioningEngineMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_LOC_POS_ENG_UNKNOWN)) {}
        IDLPositioningEngineMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_LOC_POS_ENG_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_STANDARD_POSITIONING_ENGINE):
                case static_cast< uint32_t>(Literal::IDL_DEAD_RECKONING_ENGINE):
                case static_cast< uint32_t>(Literal::IDL_PRECISE_POSITIONING_ENGINE):
                case static_cast< uint32_t>(Literal::IDL_VP_POSITIONING_ENGINE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLPositioningEngineMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLPositioningEngineMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLPositioningEngineMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLPositioningEngineMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLPositioningEngineMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLPositioningEngineMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_LOC_POS_ENG_UNKNOWN): return "IDL_LOC_POS_ENG_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_STANDARD_POSITIONING_ENGINE): return "IDL_STANDARD_POSITIONING_ENGINE";
            case static_cast< uint32_t>(Literal::IDL_DEAD_RECKONING_ENGINE): return "IDL_DEAD_RECKONING_ENGINE";
            case static_cast< uint32_t>(Literal::IDL_PRECISE_POSITIONING_ENGINE): return "IDL_PRECISE_POSITIONING_ENGINE";
            case static_cast< uint32_t>(Literal::IDL_VP_POSITIONING_ENGINE): return "IDL_VP_POSITIONING_ENGINE";
            default: return "UNDEFINED";
            }
        }
    };
    struct IDLLocation : CommonAPI::Struct< uint32_t, uint64_t, double, double, double, float, float, float, float, float, float, uint32_t, uint64_t, uint64_t, float> {
    
        IDLLocation()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0ull;
            std::get< 2>(values_) = 0.0;
            std::get< 3>(values_) = 0.0;
            std::get< 4>(values_) = 0.0;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = 0.0f;
            std::get< 10>(values_) = 0.0f;
            std::get< 11>(values_) = 0ul;
            std::get< 12>(values_) = 0ull;
            std::get< 13>(values_) = 0ull;
            std::get< 14>(values_) = 0.0f;
        }
        IDLLocation(const uint32_t &_flags, const uint64_t &_timestamp, const double &_latitude, const double &_longitude, const double &_altitude, const float &_speed, const float &_bearing, const float &_horizontalAccuracy, const float &_verticalAccuracy, const float &_speedAccuracy, const float &_bearingAccuracy, const uint32_t &_techMask, const uint64_t &_elapsedRealTimeNs, const uint64_t &_elapsedRealTimeUncNs, const float &_timeUncMs)
        {
            std::get< 0>(values_) = _flags;
            std::get< 1>(values_) = _timestamp;
            std::get< 2>(values_) = _latitude;
            std::get< 3>(values_) = _longitude;
            std::get< 4>(values_) = _altitude;
            std::get< 5>(values_) = _speed;
            std::get< 6>(values_) = _bearing;
            std::get< 7>(values_) = _horizontalAccuracy;
            std::get< 8>(values_) = _verticalAccuracy;
            std::get< 9>(values_) = _speedAccuracy;
            std::get< 10>(values_) = _bearingAccuracy;
            std::get< 11>(values_) = _techMask;
            std::get< 12>(values_) = _elapsedRealTimeNs;
            std::get< 13>(values_) = _elapsedRealTimeUncNs;
            std::get< 14>(values_) = _timeUncMs;
        }
        inline const uint32_t &getFlags() const { return std::get< 0>(values_); }
        inline void setFlags(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint64_t &getTimestamp() const { return std::get< 1>(values_); }
        inline void setTimestamp(const uint64_t &_value) { std::get< 1>(values_) = _value; }
        inline const double &getLatitude() const { return std::get< 2>(values_); }
        inline void setLatitude(const double &_value) { std::get< 2>(values_) = _value; }
        inline const double &getLongitude() const { return std::get< 3>(values_); }
        inline void setLongitude(const double &_value) { std::get< 3>(values_) = _value; }
        inline const double &getAltitude() const { return std::get< 4>(values_); }
        inline void setAltitude(const double &_value) { std::get< 4>(values_) = _value; }
        inline const float &getSpeed() const { return std::get< 5>(values_); }
        inline void setSpeed(const float &_value) { std::get< 5>(values_) = _value; }
        inline const float &getBearing() const { return std::get< 6>(values_); }
        inline void setBearing(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getHorizontalAccuracy() const { return std::get< 7>(values_); }
        inline void setHorizontalAccuracy(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getVerticalAccuracy() const { return std::get< 8>(values_); }
        inline void setVerticalAccuracy(const float &_value) { std::get< 8>(values_) = _value; }
        inline const float &getSpeedAccuracy() const { return std::get< 9>(values_); }
        inline void setSpeedAccuracy(const float &_value) { std::get< 9>(values_) = _value; }
        inline const float &getBearingAccuracy() const { return std::get< 10>(values_); }
        inline void setBearingAccuracy(const float &_value) { std::get< 10>(values_) = _value; }
        inline const uint32_t &getTechMask() const { return std::get< 11>(values_); }
        inline void setTechMask(const uint32_t &_value) { std::get< 11>(values_) = _value; }
        inline const uint64_t &getElapsedRealTimeNs() const { return std::get< 12>(values_); }
        inline void setElapsedRealTimeNs(const uint64_t &_value) { std::get< 12>(values_) = _value; }
        inline const uint64_t &getElapsedRealTimeUncNs() const { return std::get< 13>(values_); }
        inline void setElapsedRealTimeUncNs(const uint64_t &_value) { std::get< 13>(values_) = _value; }
        inline const float &getTimeUncMs() const { return std::get< 14>(values_); }
        inline void setTimeUncMs(const float &_value) { std::get< 14>(values_) = _value; }
        inline bool operator==(const IDLLocation& _other) const {
        return (getFlags() == _other.getFlags() && getTimestamp() == _other.getTimestamp() && getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude() && getAltitude() == _other.getAltitude() && getSpeed() == _other.getSpeed() && getBearing() == _other.getBearing() && getHorizontalAccuracy() == _other.getHorizontalAccuracy() && getVerticalAccuracy() == _other.getVerticalAccuracy() && getSpeedAccuracy() == _other.getSpeedAccuracy() && getBearingAccuracy() == _other.getBearingAccuracy() && getTechMask() == _other.getTechMask() && getElapsedRealTimeNs() == _other.getElapsedRealTimeNs() && getElapsedRealTimeUncNs() == _other.getElapsedRealTimeUncNs() && getTimeUncMs() == _other.getTimeUncMs());
        }
        inline bool operator!=(const IDLLocation &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLLLAInfo : CommonAPI::Struct< double, double, float> {
    
        IDLLLAInfo()
        {
            std::get< 0>(values_) = 0.0;
            std::get< 1>(values_) = 0.0;
            std::get< 2>(values_) = 0.0f;
        }
        IDLLLAInfo(const double &_latitude, const double &_longitude, const float &_altitude)
        {
            std::get< 0>(values_) = _latitude;
            std::get< 1>(values_) = _longitude;
            std::get< 2>(values_) = _altitude;
        }
        inline const double &getLatitude() const { return std::get< 0>(values_); }
        inline void setLatitude(const double &_value) { std::get< 0>(values_) = _value; }
        inline const double &getLongitude() const { return std::get< 1>(values_); }
        inline void setLongitude(const double &_value) { std::get< 1>(values_) = _value; }
        inline const float &getAltitude() const { return std::get< 2>(values_); }
        inline void setAltitude(const float &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const IDLLLAInfo& _other) const {
        return (getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude() && getAltitude() == _other.getAltitude());
        }
        inline bool operator!=(const IDLLLAInfo &_other) const {
            return !((*this) == _other);
        }
    
    };
    
    struct IDLDrSolutionStatusMask : CommonAPI::Enumeration< uint64_t> {
        enum Literal : uint64_t {
            IDL_DR_SOLUTION_STATUS_UNKNOWN = 0,
            IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_DETECTED = 1,
            IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_USED = 2,
            IDL_DR_SOLUTION_STATUS_WARNING_UNCALIBRATED = 4,
            IDL_DR_SOLUTION_STATUS_WARNING_GNSS_QUALITY_INSUFFICIENT = 8,
            IDL_DR_SOLUTION_STATUS_WARNING_FERRY_DETECTED = 16,
            IDL_DR_SOLUTION_STATUS_ERROR_6DOF_SENSOR_UNAVAILABLE = 32,
            IDL_DR_SOLUTION_STATUS_ERROR_VEHICLE_SPEED_UNAVAILABLE = 64,
            IDL_DR_SOLUTION_STATUS_ERROR_GNSS_EPH_UNAVAILABLE = 128,
            IDL_DR_SOLUTION_STATUS_ERROR_GNSS_MEAS_UNAVAILABLE = 256,
            IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_INVALID = 512,
            IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_UNRELIABLE = 1024,
            IDL_DR_SOLUTION_STATUS_WARNING_POSITON_UNRELIABLE = 2048,
            IDL_DR_SOLUTION_STATUS_ERROR_GENERIC = 4096,
            IDL_DR_SOLUTION_STATUS_WARNING_SENSOR_TEMP_OUT_OF_RANGE = 8192,
            IDL_DR_SOLUTION_STATUS_WARNING_USER_DYNAMICS_INSUFFICIENT = 16384,
            IDL_DR_SOLUTION_STATUS_WARNING_FACTORY_DATA_INCONSISTENT = 32768,
            DSSM_WARNING_MMF_UNAVAILABLE = 65536,
            DSSM_WARNING_MMF_NOT_USABLE = 131072
        };
    
        IDLDrSolutionStatusMask()
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_UNKNOWN)) {}
        IDLDrSolutionStatusMask(Literal _literal)
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_UNKNOWN):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_DETECTED):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_USED):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_UNCALIBRATED):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_GNSS_QUALITY_INSUFFICIENT):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_FERRY_DETECTED):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_6DOF_SENSOR_UNAVAILABLE):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_VEHICLE_SPEED_UNAVAILABLE):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_GNSS_EPH_UNAVAILABLE):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_GNSS_MEAS_UNAVAILABLE):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_INVALID):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_UNRELIABLE):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_POSITON_UNRELIABLE):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_GENERIC):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_SENSOR_TEMP_OUT_OF_RANGE):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_USER_DYNAMICS_INSUFFICIENT):
                case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_FACTORY_DATA_INCONSISTENT):
                case static_cast< uint64_t>(Literal::DSSM_WARNING_MMF_UNAVAILABLE):
                case static_cast< uint64_t>(Literal::DSSM_WARNING_MMF_NOT_USABLE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLDrSolutionStatusMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLDrSolutionStatusMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLDrSolutionStatusMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLDrSolutionStatusMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLDrSolutionStatusMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLDrSolutionStatusMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint64_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint64_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint64_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint64_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint64_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint64_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_UNKNOWN): return "IDL_DR_SOLUTION_STATUS_UNKNOWN";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_DETECTED): return "IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_DETECTED";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_USED): return "IDL_DR_SOLUTION_STATUS_VEHICLE_SENSOR_SPEED_INPUT_USED";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_UNCALIBRATED): return "IDL_DR_SOLUTION_STATUS_WARNING_UNCALIBRATED";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_GNSS_QUALITY_INSUFFICIENT): return "IDL_DR_SOLUTION_STATUS_WARNING_GNSS_QUALITY_INSUFFICIENT";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_FERRY_DETECTED): return "IDL_DR_SOLUTION_STATUS_WARNING_FERRY_DETECTED";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_6DOF_SENSOR_UNAVAILABLE): return "IDL_DR_SOLUTION_STATUS_ERROR_6DOF_SENSOR_UNAVAILABLE";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_VEHICLE_SPEED_UNAVAILABLE): return "IDL_DR_SOLUTION_STATUS_ERROR_VEHICLE_SPEED_UNAVAILABLE";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_GNSS_EPH_UNAVAILABLE): return "IDL_DR_SOLUTION_STATUS_ERROR_GNSS_EPH_UNAVAILABLE";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_GNSS_MEAS_UNAVAILABLE): return "IDL_DR_SOLUTION_STATUS_ERROR_GNSS_MEAS_UNAVAILABLE";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_INVALID): return "IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_INVALID";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_UNRELIABLE): return "IDL_DR_SOLUTION_STATUS_WARNING_INIT_POSITION_UNRELIABLE";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_POSITON_UNRELIABLE): return "IDL_DR_SOLUTION_STATUS_WARNING_POSITON_UNRELIABLE";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_ERROR_GENERIC): return "IDL_DR_SOLUTION_STATUS_ERROR_GENERIC";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_SENSOR_TEMP_OUT_OF_RANGE): return "IDL_DR_SOLUTION_STATUS_WARNING_SENSOR_TEMP_OUT_OF_RANGE";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_USER_DYNAMICS_INSUFFICIENT): return "IDL_DR_SOLUTION_STATUS_WARNING_USER_DYNAMICS_INSUFFICIENT";
            case static_cast< uint64_t>(Literal::IDL_DR_SOLUTION_STATUS_WARNING_FACTORY_DATA_INCONSISTENT): return "IDL_DR_SOLUTION_STATUS_WARNING_FACTORY_DATA_INCONSISTENT";
            case static_cast< uint64_t>(Literal::DSSM_WARNING_MMF_UNAVAILABLE): return "DSSM_WARNING_MMF_UNAVAILABLE";
            case static_cast< uint64_t>(Literal::DSSM_WARNING_MMF_NOT_USABLE): return "DSSM_WARNING_MMF_NOT_USABLE";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLLocSessionStatus : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            IDL_LOC_SESS_UNKNOWN = 0,
            IDL_LOC_SESS_SUCCESS = 1,
            IDL_LOC_SESS_INTERMEDIATE = 2,
            IDL_LOC_SESS_FAILURE = 3
        };
    
        IDLLocSessionStatus()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::IDL_LOC_SESS_UNKNOWN)) {}
        IDLLocSessionStatus(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::IDL_LOC_SESS_UNKNOWN):
                case static_cast< uint8_t>(Literal::IDL_LOC_SESS_SUCCESS):
                case static_cast< uint8_t>(Literal::IDL_LOC_SESS_INTERMEDIATE):
                case static_cast< uint8_t>(Literal::IDL_LOC_SESS_FAILURE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLLocSessionStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLLocSessionStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLLocSessionStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLLocSessionStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLLocSessionStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLLocSessionStatus &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::IDL_LOC_SESS_UNKNOWN): return "IDL_LOC_SESS_UNKNOWN";
            case static_cast< uint8_t>(Literal::IDL_LOC_SESS_SUCCESS): return "IDL_LOC_SESS_SUCCESS";
            case static_cast< uint8_t>(Literal::IDL_LOC_SESS_INTERMEDIATE): return "IDL_LOC_SESS_INTERMEDIATE";
            case static_cast< uint8_t>(Literal::IDL_LOC_SESS_FAILURE): return "IDL_LOC_SESS_FAILURE";
            default: return "UNDEFINED";
            }
        }
    };
    struct IDLLocationReport : CommonAPI::Struct< IDLLocation, uint64_t, float, float, float, float, float, float, float, uint32_t, uint32_t, float, float, float, float, float, float, float, float, float, float, float, uint16_t, IDLLocationReportSvUsedInPosition, uint32_t, uint32_t, IDLLocationReportPositionDynamics, IDLGnssSystemTime, std::vector< IDLGnssMeasUsageInfo >, uint8_t, uint8_t, uint64_t, IDLLocOutputEngineType, uint32_t, float, IDLLLAInfo, std::vector< float >, uint64_t, bool, uint32_t, uint32_t, float, float, float, std::vector< uint16_t >, uint64_t, uint64_t, double, uint64_t, uint32_t, int16_t, uint8_t> {
    
        IDLLocationReport()
        {
            std::get< 0>(values_) = IDLLocation();
            std::get< 1>(values_) = 0ull;
            std::get< 2>(values_) = 0.0f;
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = 0ul;
            std::get< 10>(values_) = 0ul;
            std::get< 11>(values_) = 0.0f;
            std::get< 12>(values_) = 0.0f;
            std::get< 13>(values_) = 0.0f;
            std::get< 14>(values_) = 0.0f;
            std::get< 15>(values_) = 0.0f;
            std::get< 16>(values_) = 0.0f;
            std::get< 17>(values_) = 0.0f;
            std::get< 18>(values_) = 0.0f;
            std::get< 19>(values_) = 0.0f;
            std::get< 20>(values_) = 0.0f;
            std::get< 21>(values_) = 0.0f;
            std::get< 22>(values_) = 0u;
            std::get< 23>(values_) = IDLLocationReportSvUsedInPosition();
            std::get< 24>(values_) = 0ul;
            std::get< 25>(values_) = 0ul;
            std::get< 26>(values_) = IDLLocationReportPositionDynamics();
            std::get< 27>(values_) = IDLGnssSystemTime();
            std::get< 28>(values_) = std::vector< IDLGnssMeasUsageInfo >();
            std::get< 29>(values_) = 0u;
            std::get< 30>(values_) = 0u;
            std::get< 31>(values_) = 0ull;
            std::get< 32>(values_) = IDLLocOutputEngineType();
            std::get< 33>(values_) = 0ul;
            std::get< 34>(values_) = 0.0f;
            std::get< 35>(values_) = IDLLLAInfo();
            std::get< 36>(values_) = std::vector< float >();
            std::get< 37>(values_) = 0ull;
            std::get< 38>(values_) = false;
            std::get< 39>(values_) = 0ul;
            std::get< 40>(values_) = 0ul;
            std::get< 41>(values_) = 0.0f;
            std::get< 42>(values_) = 0.0f;
            std::get< 43>(values_) = 0.0f;
            std::get< 44>(values_) = std::vector< uint16_t >();
            std::get< 45>(values_) = 0ull;
            std::get< 46>(values_) = 0ull;
            std::get< 47>(values_) = 0.0;
            std::get< 48>(values_) = 0ull;
            std::get< 49>(values_) = 0ul;
            std::get< 50>(values_) = 0;
            std::get< 51>(values_) = 0u;
        }
        IDLLocationReport(const IDLLocation &_locInfo, const uint64_t &_locationInfoFlags, const float &_altitudeMeanSeaLevel, const float &_pdop, const float &_hdop, const float &_vdop, const float &_gdop, const float &_tdop, const float &_magneticDeviation, const uint32_t &_horReliability, const uint32_t &_verReliability, const float &_horUncEllipseSemiMajor, const float &_horUncEllipseSemiMinor, const float &_horUncEllipseOrientAzimuth, const float &_northStdDeviation, const float &_eastStdDeviation, const float &_northVelocity, const float &_eastVelocity, const float &_upVelocity, const float &_northVelocityStdDeviation, const float &_eastVelocityStdDeviation, const float &_upVelocityStdDeviation, const uint16_t &_numSvUsedInPosition, const IDLLocationReportSvUsedInPosition &_svUsedInPosition, const uint32_t &_navSolutionMask, const uint32_t &_posTechMask, const IDLLocationReportPositionDynamics &_bodyFrameData, const IDLGnssSystemTime &_gnssSystemTime, const std::vector< IDLGnssMeasUsageInfo > &_measUsageInfo, const uint8_t &_leapSeconds, const uint8_t &_calibrationConfidencePercent, const uint64_t &_calibrationStatus, const IDLLocOutputEngineType &_locOutputEngType, const uint32_t &_locOutputEngMask, const float &_conformityIndex, const IDLLLAInfo &_llaVRPBased, const std::vector< float > &_enuVelocityVRPBased, const uint64_t &_drSolutionStatusMask, const bool &_altitudeAssumed, const uint32_t &_sessionStatus, const uint32_t &_integrityRiskUsed, const float &_protectAlongTrack, const float &_protectCrossTrack, const float &_protectVertical, const std::vector< uint16_t > &_dgnssStationId, const uint64_t &_elapsedgPTPTime, const uint64_t &_elapsedgPTPTimeUnc, const double &_baseLineLength, const uint64_t &_ageMsecOfCorrections, const uint32_t &_currReportingRate, const int16_t &_reportingLatency, const uint8_t &_leapSecondsUnc)
        {
            std::get< 0>(values_) = _locInfo;
            std::get< 1>(values_) = _locationInfoFlags;
            std::get< 2>(values_) = _altitudeMeanSeaLevel;
            std::get< 3>(values_) = _pdop;
            std::get< 4>(values_) = _hdop;
            std::get< 5>(values_) = _vdop;
            std::get< 6>(values_) = _gdop;
            std::get< 7>(values_) = _tdop;
            std::get< 8>(values_) = _magneticDeviation;
            std::get< 9>(values_) = _horReliability;
            std::get< 10>(values_) = _verReliability;
            std::get< 11>(values_) = _horUncEllipseSemiMajor;
            std::get< 12>(values_) = _horUncEllipseSemiMinor;
            std::get< 13>(values_) = _horUncEllipseOrientAzimuth;
            std::get< 14>(values_) = _northStdDeviation;
            std::get< 15>(values_) = _eastStdDeviation;
            std::get< 16>(values_) = _northVelocity;
            std::get< 17>(values_) = _eastVelocity;
            std::get< 18>(values_) = _upVelocity;
            std::get< 19>(values_) = _northVelocityStdDeviation;
            std::get< 20>(values_) = _eastVelocityStdDeviation;
            std::get< 21>(values_) = _upVelocityStdDeviation;
            std::get< 22>(values_) = _numSvUsedInPosition;
            std::get< 23>(values_) = _svUsedInPosition;
            std::get< 24>(values_) = _navSolutionMask;
            std::get< 25>(values_) = _posTechMask;
            std::get< 26>(values_) = _bodyFrameData;
            std::get< 27>(values_) = _gnssSystemTime;
            std::get< 28>(values_) = _measUsageInfo;
            std::get< 29>(values_) = _leapSeconds;
            std::get< 30>(values_) = _calibrationConfidencePercent;
            std::get< 31>(values_) = _calibrationStatus;
            std::get< 32>(values_) = _locOutputEngType;
            std::get< 33>(values_) = _locOutputEngMask;
            std::get< 34>(values_) = _conformityIndex;
            std::get< 35>(values_) = _llaVRPBased;
            std::get< 36>(values_) = _enuVelocityVRPBased;
            std::get< 37>(values_) = _drSolutionStatusMask;
            std::get< 38>(values_) = _altitudeAssumed;
            std::get< 39>(values_) = _sessionStatus;
            std::get< 40>(values_) = _integrityRiskUsed;
            std::get< 41>(values_) = _protectAlongTrack;
            std::get< 42>(values_) = _protectCrossTrack;
            std::get< 43>(values_) = _protectVertical;
            std::get< 44>(values_) = _dgnssStationId;
            std::get< 45>(values_) = _elapsedgPTPTime;
            std::get< 46>(values_) = _elapsedgPTPTimeUnc;
            std::get< 47>(values_) = _baseLineLength;
            std::get< 48>(values_) = _ageMsecOfCorrections;
            std::get< 49>(values_) = _currReportingRate;
            std::get< 50>(values_) = _reportingLatency;
            std::get< 51>(values_) = _leapSecondsUnc;
        }
        inline const IDLLocation &getLocInfo() const { return std::get< 0>(values_); }
        inline void setLocInfo(const IDLLocation &_value) { std::get< 0>(values_) = _value; }
        inline const uint64_t &getLocationInfoFlags() const { return std::get< 1>(values_); }
        inline void setLocationInfoFlags(const uint64_t &_value) { std::get< 1>(values_) = _value; }
        inline const float &getAltitudeMeanSeaLevel() const { return std::get< 2>(values_); }
        inline void setAltitudeMeanSeaLevel(const float &_value) { std::get< 2>(values_) = _value; }
        inline const float &getPdop() const { return std::get< 3>(values_); }
        inline void setPdop(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getHdop() const { return std::get< 4>(values_); }
        inline void setHdop(const float &_value) { std::get< 4>(values_) = _value; }
        inline const float &getVdop() const { return std::get< 5>(values_); }
        inline void setVdop(const float &_value) { std::get< 5>(values_) = _value; }
        inline const float &getGdop() const { return std::get< 6>(values_); }
        inline void setGdop(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getTdop() const { return std::get< 7>(values_); }
        inline void setTdop(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getMagneticDeviation() const { return std::get< 8>(values_); }
        inline void setMagneticDeviation(const float &_value) { std::get< 8>(values_) = _value; }
        inline const uint32_t &getHorReliability() const { return std::get< 9>(values_); }
        inline void setHorReliability(const uint32_t &_value) { std::get< 9>(values_) = _value; }
        inline const uint32_t &getVerReliability() const { return std::get< 10>(values_); }
        inline void setVerReliability(const uint32_t &_value) { std::get< 10>(values_) = _value; }
        inline const float &getHorUncEllipseSemiMajor() const { return std::get< 11>(values_); }
        inline void setHorUncEllipseSemiMajor(const float &_value) { std::get< 11>(values_) = _value; }
        inline const float &getHorUncEllipseSemiMinor() const { return std::get< 12>(values_); }
        inline void setHorUncEllipseSemiMinor(const float &_value) { std::get< 12>(values_) = _value; }
        inline const float &getHorUncEllipseOrientAzimuth() const { return std::get< 13>(values_); }
        inline void setHorUncEllipseOrientAzimuth(const float &_value) { std::get< 13>(values_) = _value; }
        inline const float &getNorthStdDeviation() const { return std::get< 14>(values_); }
        inline void setNorthStdDeviation(const float &_value) { std::get< 14>(values_) = _value; }
        inline const float &getEastStdDeviation() const { return std::get< 15>(values_); }
        inline void setEastStdDeviation(const float &_value) { std::get< 15>(values_) = _value; }
        inline const float &getNorthVelocity() const { return std::get< 16>(values_); }
        inline void setNorthVelocity(const float &_value) { std::get< 16>(values_) = _value; }
        inline const float &getEastVelocity() const { return std::get< 17>(values_); }
        inline void setEastVelocity(const float &_value) { std::get< 17>(values_) = _value; }
        inline const float &getUpVelocity() const { return std::get< 18>(values_); }
        inline void setUpVelocity(const float &_value) { std::get< 18>(values_) = _value; }
        inline const float &getNorthVelocityStdDeviation() const { return std::get< 19>(values_); }
        inline void setNorthVelocityStdDeviation(const float &_value) { std::get< 19>(values_) = _value; }
        inline const float &getEastVelocityStdDeviation() const { return std::get< 20>(values_); }
        inline void setEastVelocityStdDeviation(const float &_value) { std::get< 20>(values_) = _value; }
        inline const float &getUpVelocityStdDeviation() const { return std::get< 21>(values_); }
        inline void setUpVelocityStdDeviation(const float &_value) { std::get< 21>(values_) = _value; }
        inline const uint16_t &getNumSvUsedInPosition() const { return std::get< 22>(values_); }
        inline void setNumSvUsedInPosition(const uint16_t &_value) { std::get< 22>(values_) = _value; }
        inline const IDLLocationReportSvUsedInPosition &getSvUsedInPosition() const { return std::get< 23>(values_); }
        inline void setSvUsedInPosition(const IDLLocationReportSvUsedInPosition &_value) { std::get< 23>(values_) = _value; }
        inline const uint32_t &getNavSolutionMask() const { return std::get< 24>(values_); }
        inline void setNavSolutionMask(const uint32_t &_value) { std::get< 24>(values_) = _value; }
        inline const uint32_t &getPosTechMask() const { return std::get< 25>(values_); }
        inline void setPosTechMask(const uint32_t &_value) { std::get< 25>(values_) = _value; }
        inline const IDLLocationReportPositionDynamics &getBodyFrameData() const { return std::get< 26>(values_); }
        inline void setBodyFrameData(const IDLLocationReportPositionDynamics &_value) { std::get< 26>(values_) = _value; }
        inline const IDLGnssSystemTime &getGnssSystemTime() const { return std::get< 27>(values_); }
        inline void setGnssSystemTime(const IDLGnssSystemTime &_value) { std::get< 27>(values_) = _value; }
        inline const std::vector< IDLGnssMeasUsageInfo > &getMeasUsageInfo() const { return std::get< 28>(values_); }
        inline void setMeasUsageInfo(const std::vector< IDLGnssMeasUsageInfo > &_value) { std::get< 28>(values_) = _value; }
        inline const uint8_t &getLeapSeconds() const { return std::get< 29>(values_); }
        inline void setLeapSeconds(const uint8_t &_value) { std::get< 29>(values_) = _value; }
        inline const uint8_t &getCalibrationConfidencePercent() const { return std::get< 30>(values_); }
        inline void setCalibrationConfidencePercent(const uint8_t &_value) { std::get< 30>(values_) = _value; }
        inline const uint64_t &getCalibrationStatus() const { return std::get< 31>(values_); }
        inline void setCalibrationStatus(const uint64_t &_value) { std::get< 31>(values_) = _value; }
        inline const IDLLocOutputEngineType &getLocOutputEngType() const { return std::get< 32>(values_); }
        inline void setLocOutputEngType(const IDLLocOutputEngineType &_value) { std::get< 32>(values_) = _value; }
        inline const uint32_t &getLocOutputEngMask() const { return std::get< 33>(values_); }
        inline void setLocOutputEngMask(const uint32_t &_value) { std::get< 33>(values_) = _value; }
        inline const float &getConformityIndex() const { return std::get< 34>(values_); }
        inline void setConformityIndex(const float &_value) { std::get< 34>(values_) = _value; }
        inline const IDLLLAInfo &getLlaVRPBased() const { return std::get< 35>(values_); }
        inline void setLlaVRPBased(const IDLLLAInfo &_value) { std::get< 35>(values_) = _value; }
        inline const std::vector< float > &getEnuVelocityVRPBased() const { return std::get< 36>(values_); }
        inline void setEnuVelocityVRPBased(const std::vector< float > &_value) { std::get< 36>(values_) = _value; }
        inline const uint64_t &getDrSolutionStatusMask() const { return std::get< 37>(values_); }
        inline void setDrSolutionStatusMask(const uint64_t &_value) { std::get< 37>(values_) = _value; }
        inline const bool &getAltitudeAssumed() const { return std::get< 38>(values_); }
        inline void setAltitudeAssumed(const bool _value) { std::get< 38>(values_) = _value; }
        inline const uint32_t &getSessionStatus() const { return std::get< 39>(values_); }
        inline void setSessionStatus(const uint32_t &_value) { std::get< 39>(values_) = _value; }
        inline const uint32_t &getIntegrityRiskUsed() const { return std::get< 40>(values_); }
        inline void setIntegrityRiskUsed(const uint32_t &_value) { std::get< 40>(values_) = _value; }
        inline const float &getProtectAlongTrack() const { return std::get< 41>(values_); }
        inline void setProtectAlongTrack(const float &_value) { std::get< 41>(values_) = _value; }
        inline const float &getProtectCrossTrack() const { return std::get< 42>(values_); }
        inline void setProtectCrossTrack(const float &_value) { std::get< 42>(values_) = _value; }
        inline const float &getProtectVertical() const { return std::get< 43>(values_); }
        inline void setProtectVertical(const float &_value) { std::get< 43>(values_) = _value; }
        inline const std::vector< uint16_t > &getDgnssStationId() const { return std::get< 44>(values_); }
        inline void setDgnssStationId(const std::vector< uint16_t > &_value) { std::get< 44>(values_) = _value; }
        inline const uint64_t &getElapsedgPTPTime() const { return std::get< 45>(values_); }
        inline void setElapsedgPTPTime(const uint64_t &_value) { std::get< 45>(values_) = _value; }
        inline const uint64_t &getElapsedgPTPTimeUnc() const { return std::get< 46>(values_); }
        inline void setElapsedgPTPTimeUnc(const uint64_t &_value) { std::get< 46>(values_) = _value; }
        inline const double &getBaseLineLength() const { return std::get< 47>(values_); }
        inline void setBaseLineLength(const double &_value) { std::get< 47>(values_) = _value; }
        inline const uint64_t &getAgeMsecOfCorrections() const { return std::get< 48>(values_); }
        inline void setAgeMsecOfCorrections(const uint64_t &_value) { std::get< 48>(values_) = _value; }
        inline const uint32_t &getCurrReportingRate() const { return std::get< 49>(values_); }
        inline void setCurrReportingRate(const uint32_t &_value) { std::get< 49>(values_) = _value; }
        inline const int16_t &getReportingLatency() const { return std::get< 50>(values_); }
        inline void setReportingLatency(const int16_t &_value) { std::get< 50>(values_) = _value; }
        inline const uint8_t &getLeapSecondsUnc() const { return std::get< 51>(values_); }
        inline void setLeapSecondsUnc(const uint8_t &_value) { std::get< 51>(values_) = _value; }
        inline bool operator==(const IDLLocationReport& _other) const {
        return (getLocInfo() == _other.getLocInfo() && getLocationInfoFlags() == _other.getLocationInfoFlags() && getAltitudeMeanSeaLevel() == _other.getAltitudeMeanSeaLevel() && getPdop() == _other.getPdop() && getHdop() == _other.getHdop() && getVdop() == _other.getVdop() && getGdop() == _other.getGdop() && getTdop() == _other.getTdop() && getMagneticDeviation() == _other.getMagneticDeviation() && getHorReliability() == _other.getHorReliability() && getVerReliability() == _other.getVerReliability() && getHorUncEllipseSemiMajor() == _other.getHorUncEllipseSemiMajor() && getHorUncEllipseSemiMinor() == _other.getHorUncEllipseSemiMinor() && getHorUncEllipseOrientAzimuth() == _other.getHorUncEllipseOrientAzimuth() && getNorthStdDeviation() == _other.getNorthStdDeviation() && getEastStdDeviation() == _other.getEastStdDeviation() && getNorthVelocity() == _other.getNorthVelocity() && getEastVelocity() == _other.getEastVelocity() && getUpVelocity() == _other.getUpVelocity() && getNorthVelocityStdDeviation() == _other.getNorthVelocityStdDeviation() && getEastVelocityStdDeviation() == _other.getEastVelocityStdDeviation() && getUpVelocityStdDeviation() == _other.getUpVelocityStdDeviation() && getNumSvUsedInPosition() == _other.getNumSvUsedInPosition() && getSvUsedInPosition() == _other.getSvUsedInPosition() && getNavSolutionMask() == _other.getNavSolutionMask() && getPosTechMask() == _other.getPosTechMask() && getBodyFrameData() == _other.getBodyFrameData() && getGnssSystemTime() == _other.getGnssSystemTime() && getMeasUsageInfo() == _other.getMeasUsageInfo() && getLeapSeconds() == _other.getLeapSeconds() && getCalibrationConfidencePercent() == _other.getCalibrationConfidencePercent() && getCalibrationStatus() == _other.getCalibrationStatus() && getLocOutputEngType() == _other.getLocOutputEngType() && getLocOutputEngMask() == _other.getLocOutputEngMask() && getConformityIndex() == _other.getConformityIndex() && getLlaVRPBased() == _other.getLlaVRPBased() && getEnuVelocityVRPBased() == _other.getEnuVelocityVRPBased() && getDrSolutionStatusMask() == _other.getDrSolutionStatusMask() && getAltitudeAssumed() == _other.getAltitudeAssumed() && getSessionStatus() == _other.getSessionStatus() && getIntegrityRiskUsed() == _other.getIntegrityRiskUsed() && getProtectAlongTrack() == _other.getProtectAlongTrack() && getProtectCrossTrack() == _other.getProtectCrossTrack() && getProtectVertical() == _other.getProtectVertical() && getDgnssStationId() == _other.getDgnssStationId() && getElapsedgPTPTime() == _other.getElapsedgPTPTime() && getElapsedgPTPTimeUnc() == _other.getElapsedgPTPTimeUnc() && getBaseLineLength() == _other.getBaseLineLength() && getAgeMsecOfCorrections() == _other.getAgeMsecOfCorrections() && getCurrReportingRate() == _other.getCurrReportingRate() && getReportingLatency() == _other.getReportingLatency() && getLeapSecondsUnc() == _other.getLeapSecondsUnc());
        }
        inline bool operator!=(const IDLLocationReport &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLGnssSv : CommonAPI::Struct< uint16_t, uint16_t, IDLGnssSvType, float, float, float, uint32_t, float, uint32_t, double> {
    
        IDLGnssSv()
        {
            std::get< 0>(values_) = 0u;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = IDLGnssSvType();
            std::get< 3>(values_) = 0.0f;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0f;
            std::get< 6>(values_) = 0ul;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0ul;
            std::get< 9>(values_) = 0.0;
        }
        IDLGnssSv(const uint16_t &_svId, const uint16_t &_gloFrequency, const IDLGnssSvType &_type, const float &_cN0Dbhz, const float &_elevation, const float &_azimuth, const uint32_t &_gnssSvOptionsMask, const float &_carrierFrequencyHz, const uint32_t &_gnssSignalTypeMask, const double &_basebandCarrierToNoiseDbHz)
        {
            std::get< 0>(values_) = _svId;
            std::get< 1>(values_) = _gloFrequency;
            std::get< 2>(values_) = _type;
            std::get< 3>(values_) = _cN0Dbhz;
            std::get< 4>(values_) = _elevation;
            std::get< 5>(values_) = _azimuth;
            std::get< 6>(values_) = _gnssSvOptionsMask;
            std::get< 7>(values_) = _carrierFrequencyHz;
            std::get< 8>(values_) = _gnssSignalTypeMask;
            std::get< 9>(values_) = _basebandCarrierToNoiseDbHz;
        }
        inline const uint16_t &getSvId() const { return std::get< 0>(values_); }
        inline void setSvId(const uint16_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint16_t &getGloFrequency() const { return std::get< 1>(values_); }
        inline void setGloFrequency(const uint16_t &_value) { std::get< 1>(values_) = _value; }
        inline const IDLGnssSvType &getType() const { return std::get< 2>(values_); }
        inline void setType(const IDLGnssSvType &_value) { std::get< 2>(values_) = _value; }
        inline const float &getCN0Dbhz() const { return std::get< 3>(values_); }
        inline void setCN0Dbhz(const float &_value) { std::get< 3>(values_) = _value; }
        inline const float &getElevation() const { return std::get< 4>(values_); }
        inline void setElevation(const float &_value) { std::get< 4>(values_) = _value; }
        inline const float &getAzimuth() const { return std::get< 5>(values_); }
        inline void setAzimuth(const float &_value) { std::get< 5>(values_) = _value; }
        inline const uint32_t &getGnssSvOptionsMask() const { return std::get< 6>(values_); }
        inline void setGnssSvOptionsMask(const uint32_t &_value) { std::get< 6>(values_) = _value; }
        inline const float &getCarrierFrequencyHz() const { return std::get< 7>(values_); }
        inline void setCarrierFrequencyHz(const float &_value) { std::get< 7>(values_) = _value; }
        inline const uint32_t &getGnssSignalTypeMask() const { return std::get< 8>(values_); }
        inline void setGnssSignalTypeMask(const uint32_t &_value) { std::get< 8>(values_) = _value; }
        inline const double &getBasebandCarrierToNoiseDbHz() const { return std::get< 9>(values_); }
        inline void setBasebandCarrierToNoiseDbHz(const double &_value) { std::get< 9>(values_) = _value; }
        inline bool operator==(const IDLGnssSv& _other) const {
        return (getSvId() == _other.getSvId() && getGloFrequency() == _other.getGloFrequency() && getType() == _other.getType() && getCN0Dbhz() == _other.getCN0Dbhz() && getElevation() == _other.getElevation() && getAzimuth() == _other.getAzimuth() && getGnssSvOptionsMask() == _other.getGnssSvOptionsMask() && getCarrierFrequencyHz() == _other.getCarrierFrequencyHz() && getGnssSignalTypeMask() == _other.getGnssSignalTypeMask() && getBasebandCarrierToNoiseDbHz() == _other.getBasebandCarrierToNoiseDbHz());
        }
        inline bool operator!=(const IDLGnssSv &_other) const {
            return !((*this) == _other);
        }
    
    };
    
    struct IDLGnssSignalTypes : CommonAPI::Enumeration< uint8_t> {
        enum Literal : uint8_t {
            IDL_GNSS_SIGNAL_TYPE_UNKNOWN = 0,
            IDL_GNSS_SIGNAL_TYPE_GPS_L1CA = 1,
            IDL_GNSS_SIGNAL_TYPE_GPS_L1C = 2,
            IDL_GNSS_SIGNAL_TYPE_GPS_L2C_L = 3,
            IDL_GNSS_SIGNAL_TYPE_GPS_L5_Q = 4,
            IDL_GNSS_SIGNAL_TYPE_GLONASS_G1 = 5,
            IDL_GNSS_SIGNAL_TYPE_GLONASS_G2 = 6,
            IDL_GNSS_SIGNAL_TYPE_GALILEO_E1_C = 7,
            IDL_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q = 8,
            IDL_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q = 9,
            IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1_I = 10,
            IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1C = 11,
            IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2_I = 12,
            IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I = 13,
            IDL_GNSS_SIGNAL_TYPE_QZSS_L1CA = 14,
            IDL_GNSS_SIGNAL_TYPE_QZSS_L1S = 15,
            IDL_GNSS_SIGNAL_TYPE_QZSS_L2C_L = 16,
            IDL_GNSS_SIGNAL_TYPE_QZSS_L5_Q = 17,
            IDL_GNSS_SIGNAL_TYPE_SBAS_L1_CA = 18,
            IDL_GNSS_SIGNAL_TYPE_NAVIC_L5 = 19,
            IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q = 20,
            IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_I = 21,
            IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_Q = 22,
            GST_NAVIC_L1 = 23,
            IDL_GNSS_MAX_NUMBER_OF_SIGNAL_TYPES = 24
        };
    
        IDLGnssSignalTypes()
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_UNKNOWN)) {}
        IDLGnssSignalTypes(Literal _literal)
            : CommonAPI::Enumeration< uint8_t>(static_cast< uint8_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_UNKNOWN):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L1CA):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L1C):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L2C_L):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L5_Q):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GLONASS_G1):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GLONASS_G2):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GALILEO_E1_C):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1_I):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1C):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2_I):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L1CA):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L1S):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L2C_L):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L5_Q):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_SBAS_L1_CA):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_NAVIC_L5):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_I):
                case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_Q):
                case static_cast< uint8_t>(Literal::GST_NAVIC_L1):
                case static_cast< uint8_t>(Literal::IDL_GNSS_MAX_NUMBER_OF_SIGNAL_TYPES):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssSignalTypes &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssSignalTypes &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssSignalTypes &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssSignalTypes &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssSignalTypes &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssSignalTypes &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint8_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint8_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint8_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint8_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint8_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint8_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_UNKNOWN): return "IDL_GNSS_SIGNAL_TYPE_UNKNOWN";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L1CA): return "IDL_GNSS_SIGNAL_TYPE_GPS_L1CA";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L1C): return "IDL_GNSS_SIGNAL_TYPE_GPS_L1C";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L2C_L): return "IDL_GNSS_SIGNAL_TYPE_GPS_L2C_L";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GPS_L5_Q): return "IDL_GNSS_SIGNAL_TYPE_GPS_L5_Q";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GLONASS_G1): return "IDL_GNSS_SIGNAL_TYPE_GLONASS_G1";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GLONASS_G2): return "IDL_GNSS_SIGNAL_TYPE_GLONASS_G2";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GALILEO_E1_C): return "IDL_GNSS_SIGNAL_TYPE_GALILEO_E1_C";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q): return "IDL_GNSS_SIGNAL_TYPE_GALILEO_E5A_Q";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q): return "IDL_GNSS_SIGNAL_TYPE_GALILEO_E5B_Q";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1_I): return "IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1_I";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1C): return "IDL_GNSS_SIGNAL_TYPE_BEIDOU_B1C";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2_I): return "IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2_I";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I): return "IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_I";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L1CA): return "IDL_GNSS_SIGNAL_TYPE_QZSS_L1CA";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L1S): return "IDL_GNSS_SIGNAL_TYPE_QZSS_L1S";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L2C_L): return "IDL_GNSS_SIGNAL_TYPE_QZSS_L2C_L";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_QZSS_L5_Q): return "IDL_GNSS_SIGNAL_TYPE_QZSS_L5_Q";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_SBAS_L1_CA): return "IDL_GNSS_SIGNAL_TYPE_SBAS_L1_CA";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_NAVIC_L5): return "IDL_GNSS_SIGNAL_TYPE_NAVIC_L5";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q): return "IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2A_Q";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_I): return "IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_I";
            case static_cast< uint8_t>(Literal::IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_Q): return "IDL_GNSS_SIGNAL_TYPE_BEIDOU_B2B_Q";
            case static_cast< uint8_t>(Literal::GST_NAVIC_L1): return "GST_NAVIC_L1";
            case static_cast< uint8_t>(Literal::IDL_GNSS_MAX_NUMBER_OF_SIGNAL_TYPES): return "IDL_GNSS_MAX_NUMBER_OF_SIGNAL_TYPES";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssDataMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_GNSS_DATA_IND_UNKNOWN = 0,
            IDL_GNSS_DATA_JAMMER_IND_BIT = 1,
            IDL_GNSS_DATA_AGC_BIT = 2
        };
    
        IDLGnssDataMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_GNSS_DATA_IND_UNKNOWN)) {}
        IDLGnssDataMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_GNSS_DATA_IND_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_GNSS_DATA_JAMMER_IND_BIT):
                case static_cast< uint32_t>(Literal::IDL_GNSS_DATA_AGC_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssDataMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssDataMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssDataMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssDataMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssDataMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssDataMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_GNSS_DATA_IND_UNKNOWN): return "IDL_GNSS_DATA_IND_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_GNSS_DATA_JAMMER_IND_BIT): return "IDL_GNSS_DATA_JAMMER_IND_BIT";
            case static_cast< uint32_t>(Literal::IDL_GNSS_DATA_AGC_BIT): return "IDL_GNSS_DATA_AGC_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    struct IDLGnssData : CommonAPI::Struct< std::vector< uint32_t >, std::vector< double >, std::vector< double >> {
    
        IDLGnssData()
        {
            std::get< 0>(values_) = std::vector< uint32_t >();
            std::get< 1>(values_) = std::vector< double >();
            std::get< 2>(values_) = std::vector< double >();
        }
        IDLGnssData(const std::vector< uint32_t > &_gnssDataMask, const std::vector< double > &_jammerInd, const std::vector< double > &_agc)
        {
            std::get< 0>(values_) = _gnssDataMask;
            std::get< 1>(values_) = _jammerInd;
            std::get< 2>(values_) = _agc;
        }
        inline const std::vector< uint32_t > &getGnssDataMask() const { return std::get< 0>(values_); }
        inline void setGnssDataMask(const std::vector< uint32_t > &_value) { std::get< 0>(values_) = _value; }
        inline const std::vector< double > &getJammerInd() const { return std::get< 1>(values_); }
        inline void setJammerInd(const std::vector< double > &_value) { std::get< 1>(values_) = _value; }
        inline const std::vector< double > &getAgc() const { return std::get< 2>(values_); }
        inline void setAgc(const std::vector< double > &_value) { std::get< 2>(values_) = _value; }
        inline bool operator==(const IDLGnssData& _other) const {
        return (getGnssDataMask() == _other.getGnssDataMask() && getJammerInd() == _other.getJammerInd() && getAgc() == _other.getAgc());
        }
        inline bool operator!=(const IDLGnssData &_other) const {
            return !((*this) == _other);
        }
    
    };
    
    struct IDLGnssMeasurementsDataFlagsMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_MEAS_DATA_UNKNOWN = 0,
            IDL_MEAS_DATA_SV_ID_BIT = 1,
            IDL_MEAS_DATA_SV_TYPE_BIT = 2,
            IDL_MEAS_DATA_STATE_BIT = 4,
            IDL_MEAS_DATA_RECEIVED_SV_TIME_BIT = 8,
            IDL_MEAS_DATA_RECVD_SV_TIME_UNC_BIT = 16,
            IDL_MEAS_DATA_CARRIER_TO_NOISE_BIT = 32,
            IDL_MEAS_DATA_PR_RATE_BIT = 64,
            IDL_MEAS_DATA_PR_RATE_UNC_BIT = 128,
            IDL_MEAS_DATA_ADR_STATE_BIT = 256,
            IDL_MEAS_DATA_ADR_BIT = 512,
            IDL_MEAS_DATA_ADR_UNC_BIT = 1024,
            IDL_MEAS_DATA_CARRIER_FREQ_BIT = 2048,
            IDL_MEAS_DATA_CARRIER_CYCLES_BIT = 4096,
            IDL_MEAS_DATA_CARRIER_PHASE_BIT = 8192,
            IDL_MEAS_DATA_CARRIER_PHASE_UNC_BIT = 16384,
            IDL_MEAS_DATA_MULTIPATH_IND_BIT = 32768,
            IDL_MEAS_DATA_SIGNAL_TO_NOISE_RATIO = 65536,
            IDL_MEAS_DATA_AUTO_GAIN_CTRL_BIT = 131072,
            IDL_MEAS_DATA_FULL_ISB_BIT = 262144,
            IDL_MEAS_DATA_FULL_ISB_UNC_BIT = 524288,
            IDL_MEAS_DATA_CYCLE_SLIP_COUNT_BIT = 1048576,
            IDL_MEAS_DATA_GNSS_SIGNAL_TYPE_BIT = 2097152,
            IDL_MEAS_DATA_BASEBAND_CARRIER_TO_NOISE_BIT = 4194304
        };
    
        IDLGnssMeasurementsDataFlagsMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_MEAS_DATA_UNKNOWN)) {}
        IDLGnssMeasurementsDataFlagsMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_SV_ID_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_SV_TYPE_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_STATE_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_RECEIVED_SV_TIME_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_RECVD_SV_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_TO_NOISE_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_PR_RATE_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_PR_RATE_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_ADR_STATE_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_ADR_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_ADR_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_FREQ_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_CYCLES_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_PHASE_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_PHASE_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_MULTIPATH_IND_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_SIGNAL_TO_NOISE_RATIO):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_AUTO_GAIN_CTRL_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_FULL_ISB_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_FULL_ISB_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CYCLE_SLIP_COUNT_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_GNSS_SIGNAL_TYPE_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_BASEBAND_CARRIER_TO_NOISE_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssMeasurementsDataFlagsMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssMeasurementsDataFlagsMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssMeasurementsDataFlagsMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssMeasurementsDataFlagsMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssMeasurementsDataFlagsMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssMeasurementsDataFlagsMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_UNKNOWN): return "IDL_MEAS_DATA_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_SV_ID_BIT): return "IDL_MEAS_DATA_SV_ID_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_SV_TYPE_BIT): return "IDL_MEAS_DATA_SV_TYPE_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_STATE_BIT): return "IDL_MEAS_DATA_STATE_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_RECEIVED_SV_TIME_BIT): return "IDL_MEAS_DATA_RECEIVED_SV_TIME_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_RECVD_SV_TIME_UNC_BIT): return "IDL_MEAS_DATA_RECVD_SV_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_TO_NOISE_BIT): return "IDL_MEAS_DATA_CARRIER_TO_NOISE_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_PR_RATE_BIT): return "IDL_MEAS_DATA_PR_RATE_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_PR_RATE_UNC_BIT): return "IDL_MEAS_DATA_PR_RATE_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_ADR_STATE_BIT): return "IDL_MEAS_DATA_ADR_STATE_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_ADR_BIT): return "IDL_MEAS_DATA_ADR_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_ADR_UNC_BIT): return "IDL_MEAS_DATA_ADR_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_FREQ_BIT): return "IDL_MEAS_DATA_CARRIER_FREQ_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_CYCLES_BIT): return "IDL_MEAS_DATA_CARRIER_CYCLES_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_PHASE_BIT): return "IDL_MEAS_DATA_CARRIER_PHASE_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CARRIER_PHASE_UNC_BIT): return "IDL_MEAS_DATA_CARRIER_PHASE_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_MULTIPATH_IND_BIT): return "IDL_MEAS_DATA_MULTIPATH_IND_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_SIGNAL_TO_NOISE_RATIO): return "IDL_MEAS_DATA_SIGNAL_TO_NOISE_RATIO";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_AUTO_GAIN_CTRL_BIT): return "IDL_MEAS_DATA_AUTO_GAIN_CTRL_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_FULL_ISB_BIT): return "IDL_MEAS_DATA_FULL_ISB_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_FULL_ISB_UNC_BIT): return "IDL_MEAS_DATA_FULL_ISB_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_CYCLE_SLIP_COUNT_BIT): return "IDL_MEAS_DATA_CYCLE_SLIP_COUNT_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_GNSS_SIGNAL_TYPE_BIT): return "IDL_MEAS_DATA_GNSS_SIGNAL_TYPE_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_DATA_BASEBAND_CARRIER_TO_NOISE_BIT): return "IDL_MEAS_DATA_BASEBAND_CARRIER_TO_NOISE_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssMeasurementsStateMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_MEAS_STATE_UNKNOWN = 0,
            IDL_MEAS_STATE_CODE_LOCK = 1,
            IDL_MEAS_STATE_BIT_SYNC = 2,
            IDL_MEAS_STATE_SUBFRAME_SYNC = 4,
            IDL_MEAS_STATE_TOW_DECODED = 8,
            IDL_MEAS_STATE_MSEC_AMBIGUOUS = 16,
            IDL_MEAS_STATE_SYMBOL_SYNC = 32,
            IDL_MEAS_STATE_GLO_STRING_SYNC = 64,
            IDL_MEAS_STATE_GLO_TOD_DECODED = 128,
            IDL_MEAS_STATE_BDS_D2_BIT_SYNC = 256,
            IDL_MEAS_STATE_BDS_D2_SUBFRAME_SYNC = 512,
            IDL_MEAS_STATE_GAL_E1BC_CODE_LOCK = 1024,
            IDL_MEAS_STATE_GAL_E1C_2ND_CODE_LOCK = 2048,
            IDL_MEAS_STATE_GAL_E1B_PAGE_SYNC = 4096,
            IDL_MEAS_STATE_SBAS_SYNC = 8192
        };
    
        IDLGnssMeasurementsStateMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_MEAS_STATE_UNKNOWN)) {}
        IDLGnssMeasurementsStateMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_CODE_LOCK):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_BIT_SYNC):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_SUBFRAME_SYNC):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_TOW_DECODED):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_MSEC_AMBIGUOUS):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_SYMBOL_SYNC):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GLO_STRING_SYNC):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GLO_TOD_DECODED):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_BDS_D2_BIT_SYNC):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_BDS_D2_SUBFRAME_SYNC):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GAL_E1BC_CODE_LOCK):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GAL_E1C_2ND_CODE_LOCK):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GAL_E1B_PAGE_SYNC):
                case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_SBAS_SYNC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssMeasurementsStateMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssMeasurementsStateMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssMeasurementsStateMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssMeasurementsStateMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssMeasurementsStateMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssMeasurementsStateMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_UNKNOWN): return "IDL_MEAS_STATE_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_CODE_LOCK): return "IDL_MEAS_STATE_CODE_LOCK";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_BIT_SYNC): return "IDL_MEAS_STATE_BIT_SYNC";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_SUBFRAME_SYNC): return "IDL_MEAS_STATE_SUBFRAME_SYNC";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_TOW_DECODED): return "IDL_MEAS_STATE_TOW_DECODED";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_MSEC_AMBIGUOUS): return "IDL_MEAS_STATE_MSEC_AMBIGUOUS";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_SYMBOL_SYNC): return "IDL_MEAS_STATE_SYMBOL_SYNC";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GLO_STRING_SYNC): return "IDL_MEAS_STATE_GLO_STRING_SYNC";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GLO_TOD_DECODED): return "IDL_MEAS_STATE_GLO_TOD_DECODED";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_BDS_D2_BIT_SYNC): return "IDL_MEAS_STATE_BDS_D2_BIT_SYNC";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_BDS_D2_SUBFRAME_SYNC): return "IDL_MEAS_STATE_BDS_D2_SUBFRAME_SYNC";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GAL_E1BC_CODE_LOCK): return "IDL_MEAS_STATE_GAL_E1BC_CODE_LOCK";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GAL_E1C_2ND_CODE_LOCK): return "IDL_MEAS_STATE_GAL_E1C_2ND_CODE_LOCK";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_GAL_E1B_PAGE_SYNC): return "IDL_MEAS_STATE_GAL_E1B_PAGE_SYNC";
            case static_cast< uint32_t>(Literal::IDL_MEAS_STATE_SBAS_SYNC): return "IDL_MEAS_STATE_SBAS_SYNC";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssMeasurementsAdrStateMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_UNKNOWN = 0,
            IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_VALID_BIT = 1,
            IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_RESET_BIT = 2,
            IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_CYCLE_SLIP_BIT = 4,
            IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_HALF_CYCLE_RESOLVED_BIT = 8
        };
    
        IDLGnssMeasurementsAdrStateMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_UNKNOWN)) {}
        IDLGnssMeasurementsAdrStateMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_VALID_BIT):
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_RESET_BIT):
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_CYCLE_SLIP_BIT):
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_HALF_CYCLE_RESOLVED_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssMeasurementsAdrStateMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssMeasurementsAdrStateMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssMeasurementsAdrStateMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssMeasurementsAdrStateMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssMeasurementsAdrStateMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssMeasurementsAdrStateMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_UNKNOWN): return "IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_VALID_BIT): return "IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_VALID_BIT";
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_RESET_BIT): return "IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_RESET_BIT";
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_CYCLE_SLIP_BIT): return "IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_CYCLE_SLIP_BIT";
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_HALF_CYCLE_RESOLVED_BIT): return "IDL_GNSS_MEASUREMENTS_ACCUMULATED_DELTA_RANGE_STATE_HALF_CYCLE_RESOLVED_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssMeasurementsMultipathIndicator : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_UNKNOWN = 0,
            IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_PRESENT = 1,
            IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_NOT_PRESENT = 2
        };
    
        IDLGnssMeasurementsMultipathIndicator()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_UNKNOWN)) {}
        IDLGnssMeasurementsMultipathIndicator(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_PRESENT):
                case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_NOT_PRESENT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssMeasurementsMultipathIndicator &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssMeasurementsMultipathIndicator &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssMeasurementsMultipathIndicator &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssMeasurementsMultipathIndicator &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssMeasurementsMultipathIndicator &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssMeasurementsMultipathIndicator &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_UNKNOWN): return "IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_PRESENT): return "IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_PRESENT";
            case static_cast< uint32_t>(Literal::IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_NOT_PRESENT): return "IDL_GNSS_MEASUREMENTS_MULTIPATH_INDICATOR_NOT_PRESENT";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssMeasurementsClockFlagsMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_MEAS_CLK_FLAGS_UNKNOWN = 0,
            IDL_MEAS_CLK_FLAGS_LEAP_SECOND_BIT = 1,
            IDL_MEAS_CLK_FLAGS_TIME_BIT = 2,
            IDL_MEAS_CLK_FLAGS_TIME_UNCERTAINTY_BIT = 4,
            IDL_MEAS_CLK_FLAGS_FULL_BIAS_BIT = 8,
            IDL_MEAS_CLK_FLAGS_BIAS_BIT = 16,
            IDL_MEAS_CLK_FLAGS_BIAS_UNCERTAINTY_BIT = 32,
            IDL_MEAS_CLK_FLAGS_DRIFT_BIT = 64,
            IDL_MEAS_CLK_FLAGS_DRIFT_UNCERTAINTY_BIT = 128,
            IDL_MEAS_CLK_HW_CLOCK_DISCONTINUITY_COUNT_BIT = 256,
            IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_BIT = 512,
            IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_UNC_BIT = 1024,
            IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_BIT = 2048,
            IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_UNC_BIT = 4096
        };
    
        IDLGnssMeasurementsClockFlagsMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_UNKNOWN)) {}
        IDLGnssMeasurementsClockFlagsMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_LEAP_SECOND_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_TIME_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_TIME_UNCERTAINTY_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_FULL_BIAS_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_BIAS_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_BIAS_UNCERTAINTY_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_DRIFT_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_DRIFT_UNCERTAINTY_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_HW_CLOCK_DISCONTINUITY_COUNT_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_UNC_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_BIT):
                case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_UNC_BIT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssMeasurementsClockFlagsMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssMeasurementsClockFlagsMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssMeasurementsClockFlagsMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssMeasurementsClockFlagsMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssMeasurementsClockFlagsMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssMeasurementsClockFlagsMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_UNKNOWN): return "IDL_MEAS_CLK_FLAGS_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_LEAP_SECOND_BIT): return "IDL_MEAS_CLK_FLAGS_LEAP_SECOND_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_TIME_BIT): return "IDL_MEAS_CLK_FLAGS_TIME_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_TIME_UNCERTAINTY_BIT): return "IDL_MEAS_CLK_FLAGS_TIME_UNCERTAINTY_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_FULL_BIAS_BIT): return "IDL_MEAS_CLK_FLAGS_FULL_BIAS_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_BIAS_BIT): return "IDL_MEAS_CLK_FLAGS_BIAS_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_BIAS_UNCERTAINTY_BIT): return "IDL_MEAS_CLK_FLAGS_BIAS_UNCERTAINTY_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_DRIFT_BIT): return "IDL_MEAS_CLK_FLAGS_DRIFT_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_DRIFT_UNCERTAINTY_BIT): return "IDL_MEAS_CLK_FLAGS_DRIFT_UNCERTAINTY_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_HW_CLOCK_DISCONTINUITY_COUNT_BIT): return "IDL_MEAS_CLK_HW_CLOCK_DISCONTINUITY_COUNT_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_BIT): return "IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_UNC_BIT): return "IDL_MEAS_CLK_FLAGS_ELAPSED_REAL_TIME_UNC_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_BIT): return "IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_BIT";
            case static_cast< uint32_t>(Literal::IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_UNC_BIT): return "IDL_MEAS_CLK_FLAGS_ELAPSED_GPTP_TIME_UNC_BIT";
            default: return "UNDEFINED";
            }
        }
    };
    struct IDLGnssMeasurementsData : CommonAPI::Struct< uint32_t, uint16_t, uint8_t, IDLGnssSvType, double, uint32_t, int64_t, float, int64_t, double, double, double, uint32_t, double, double, float, int64_t, double, double, uint32_t, double, double, double, uint32_t, double, double> {
    
        IDLGnssMeasurementsData()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0u;
            std::get< 2>(values_) = 0u;
            std::get< 3>(values_) = IDLGnssSvType();
            std::get< 4>(values_) = 0.0;
            std::get< 5>(values_) = 0ul;
            std::get< 6>(values_) = 0;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0;
            std::get< 9>(values_) = 0.0;
            std::get< 10>(values_) = 0.0;
            std::get< 11>(values_) = 0.0;
            std::get< 12>(values_) = 0ul;
            std::get< 13>(values_) = 0.0;
            std::get< 14>(values_) = 0.0;
            std::get< 15>(values_) = 0.0f;
            std::get< 16>(values_) = 0;
            std::get< 17>(values_) = 0.0;
            std::get< 18>(values_) = 0.0;
            std::get< 19>(values_) = 0ul;
            std::get< 20>(values_) = 0.0;
            std::get< 21>(values_) = 0.0;
            std::get< 22>(values_) = 0.0;
            std::get< 23>(values_) = 0ul;
            std::get< 24>(values_) = 0.0;
            std::get< 25>(values_) = 0.0;
        }
        IDLGnssMeasurementsData(const uint32_t &_flags, const uint16_t &_svId, const uint8_t &_cycleSlipCount, const IDLGnssSvType &_svType, const double &_timeOffsetNs, const uint32_t &_stateMask, const int64_t &_receivedSvTimeNs, const float &_receivedSvTimeSubNs, const int64_t &_receivedSvTimeUncertaintyNs, const double &_carrierToNoiseDbHz, const double &_pseudorangeRateMps, const double &_pseudorangeRateUncertaintyMps, const uint32_t &_adrStateMask, const double &_adrMeters, const double &_adrUncertaintyMeters, const float &_carrierFrequencyHz, const int64_t &_carrierCycles, const double &_carrierPhase, const double &_carrierPhaseUncertainty, const uint32_t &_multipathIndicator, const double &_signalToNoiseRatioDb, const double &_agcLevelDb, const double &_basebandCarrierToNoiseDbHz, const uint32_t &_gnssSignalType, const double &_fullInterSignalBiasNs, const double &_fullInterSignalBiasUncertaintyNs)
        {
            std::get< 0>(values_) = _flags;
            std::get< 1>(values_) = _svId;
            std::get< 2>(values_) = _cycleSlipCount;
            std::get< 3>(values_) = _svType;
            std::get< 4>(values_) = _timeOffsetNs;
            std::get< 5>(values_) = _stateMask;
            std::get< 6>(values_) = _receivedSvTimeNs;
            std::get< 7>(values_) = _receivedSvTimeSubNs;
            std::get< 8>(values_) = _receivedSvTimeUncertaintyNs;
            std::get< 9>(values_) = _carrierToNoiseDbHz;
            std::get< 10>(values_) = _pseudorangeRateMps;
            std::get< 11>(values_) = _pseudorangeRateUncertaintyMps;
            std::get< 12>(values_) = _adrStateMask;
            std::get< 13>(values_) = _adrMeters;
            std::get< 14>(values_) = _adrUncertaintyMeters;
            std::get< 15>(values_) = _carrierFrequencyHz;
            std::get< 16>(values_) = _carrierCycles;
            std::get< 17>(values_) = _carrierPhase;
            std::get< 18>(values_) = _carrierPhaseUncertainty;
            std::get< 19>(values_) = _multipathIndicator;
            std::get< 20>(values_) = _signalToNoiseRatioDb;
            std::get< 21>(values_) = _agcLevelDb;
            std::get< 22>(values_) = _basebandCarrierToNoiseDbHz;
            std::get< 23>(values_) = _gnssSignalType;
            std::get< 24>(values_) = _fullInterSignalBiasNs;
            std::get< 25>(values_) = _fullInterSignalBiasUncertaintyNs;
        }
        inline const uint32_t &getFlags() const { return std::get< 0>(values_); }
        inline void setFlags(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint16_t &getSvId() const { return std::get< 1>(values_); }
        inline void setSvId(const uint16_t &_value) { std::get< 1>(values_) = _value; }
        inline const uint8_t &getCycleSlipCount() const { return std::get< 2>(values_); }
        inline void setCycleSlipCount(const uint8_t &_value) { std::get< 2>(values_) = _value; }
        inline const IDLGnssSvType &getSvType() const { return std::get< 3>(values_); }
        inline void setSvType(const IDLGnssSvType &_value) { std::get< 3>(values_) = _value; }
        inline const double &getTimeOffsetNs() const { return std::get< 4>(values_); }
        inline void setTimeOffsetNs(const double &_value) { std::get< 4>(values_) = _value; }
        inline const uint32_t &getStateMask() const { return std::get< 5>(values_); }
        inline void setStateMask(const uint32_t &_value) { std::get< 5>(values_) = _value; }
        inline const int64_t &getReceivedSvTimeNs() const { return std::get< 6>(values_); }
        inline void setReceivedSvTimeNs(const int64_t &_value) { std::get< 6>(values_) = _value; }
        inline const float &getReceivedSvTimeSubNs() const { return std::get< 7>(values_); }
        inline void setReceivedSvTimeSubNs(const float &_value) { std::get< 7>(values_) = _value; }
        inline const int64_t &getReceivedSvTimeUncertaintyNs() const { return std::get< 8>(values_); }
        inline void setReceivedSvTimeUncertaintyNs(const int64_t &_value) { std::get< 8>(values_) = _value; }
        inline const double &getCarrierToNoiseDbHz() const { return std::get< 9>(values_); }
        inline void setCarrierToNoiseDbHz(const double &_value) { std::get< 9>(values_) = _value; }
        inline const double &getPseudorangeRateMps() const { return std::get< 10>(values_); }
        inline void setPseudorangeRateMps(const double &_value) { std::get< 10>(values_) = _value; }
        inline const double &getPseudorangeRateUncertaintyMps() const { return std::get< 11>(values_); }
        inline void setPseudorangeRateUncertaintyMps(const double &_value) { std::get< 11>(values_) = _value; }
        inline const uint32_t &getAdrStateMask() const { return std::get< 12>(values_); }
        inline void setAdrStateMask(const uint32_t &_value) { std::get< 12>(values_) = _value; }
        inline const double &getAdrMeters() const { return std::get< 13>(values_); }
        inline void setAdrMeters(const double &_value) { std::get< 13>(values_) = _value; }
        inline const double &getAdrUncertaintyMeters() const { return std::get< 14>(values_); }
        inline void setAdrUncertaintyMeters(const double &_value) { std::get< 14>(values_) = _value; }
        inline const float &getCarrierFrequencyHz() const { return std::get< 15>(values_); }
        inline void setCarrierFrequencyHz(const float &_value) { std::get< 15>(values_) = _value; }
        inline const int64_t &getCarrierCycles() const { return std::get< 16>(values_); }
        inline void setCarrierCycles(const int64_t &_value) { std::get< 16>(values_) = _value; }
        inline const double &getCarrierPhase() const { return std::get< 17>(values_); }
        inline void setCarrierPhase(const double &_value) { std::get< 17>(values_) = _value; }
        inline const double &getCarrierPhaseUncertainty() const { return std::get< 18>(values_); }
        inline void setCarrierPhaseUncertainty(const double &_value) { std::get< 18>(values_) = _value; }
        inline const uint32_t &getMultipathIndicator() const { return std::get< 19>(values_); }
        inline void setMultipathIndicator(const uint32_t &_value) { std::get< 19>(values_) = _value; }
        inline const double &getSignalToNoiseRatioDb() const { return std::get< 20>(values_); }
        inline void setSignalToNoiseRatioDb(const double &_value) { std::get< 20>(values_) = _value; }
        inline const double &getAgcLevelDb() const { return std::get< 21>(values_); }
        inline void setAgcLevelDb(const double &_value) { std::get< 21>(values_) = _value; }
        inline const double &getBasebandCarrierToNoiseDbHz() const { return std::get< 22>(values_); }
        inline void setBasebandCarrierToNoiseDbHz(const double &_value) { std::get< 22>(values_) = _value; }
        inline const uint32_t &getGnssSignalType() const { return std::get< 23>(values_); }
        inline void setGnssSignalType(const uint32_t &_value) { std::get< 23>(values_) = _value; }
        inline const double &getFullInterSignalBiasNs() const { return std::get< 24>(values_); }
        inline void setFullInterSignalBiasNs(const double &_value) { std::get< 24>(values_) = _value; }
        inline const double &getFullInterSignalBiasUncertaintyNs() const { return std::get< 25>(values_); }
        inline void setFullInterSignalBiasUncertaintyNs(const double &_value) { std::get< 25>(values_) = _value; }
        inline bool operator==(const IDLGnssMeasurementsData& _other) const {
        return (getFlags() == _other.getFlags() && getSvId() == _other.getSvId() && getCycleSlipCount() == _other.getCycleSlipCount() && getSvType() == _other.getSvType() && getTimeOffsetNs() == _other.getTimeOffsetNs() && getStateMask() == _other.getStateMask() && getReceivedSvTimeNs() == _other.getReceivedSvTimeNs() && getReceivedSvTimeSubNs() == _other.getReceivedSvTimeSubNs() && getReceivedSvTimeUncertaintyNs() == _other.getReceivedSvTimeUncertaintyNs() && getCarrierToNoiseDbHz() == _other.getCarrierToNoiseDbHz() && getPseudorangeRateMps() == _other.getPseudorangeRateMps() && getPseudorangeRateUncertaintyMps() == _other.getPseudorangeRateUncertaintyMps() && getAdrStateMask() == _other.getAdrStateMask() && getAdrMeters() == _other.getAdrMeters() && getAdrUncertaintyMeters() == _other.getAdrUncertaintyMeters() && getCarrierFrequencyHz() == _other.getCarrierFrequencyHz() && getCarrierCycles() == _other.getCarrierCycles() && getCarrierPhase() == _other.getCarrierPhase() && getCarrierPhaseUncertainty() == _other.getCarrierPhaseUncertainty() && getMultipathIndicator() == _other.getMultipathIndicator() && getSignalToNoiseRatioDb() == _other.getSignalToNoiseRatioDb() && getAgcLevelDb() == _other.getAgcLevelDb() && getBasebandCarrierToNoiseDbHz() == _other.getBasebandCarrierToNoiseDbHz() && getGnssSignalType() == _other.getGnssSignalType() && getFullInterSignalBiasNs() == _other.getFullInterSignalBiasNs() && getFullInterSignalBiasUncertaintyNs() == _other.getFullInterSignalBiasUncertaintyNs());
        }
        inline bool operator!=(const IDLGnssMeasurementsData &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLGnssMeasurementsClock : CommonAPI::Struct< uint32_t, int16_t, int64_t, double, int64_t, double, double, double, double, uint32_t, uint64_t, uint64_t, uint64_t, uint64_t> {
    
        IDLGnssMeasurementsClock()
        {
            std::get< 0>(values_) = 0ul;
            std::get< 1>(values_) = 0;
            std::get< 2>(values_) = 0;
            std::get< 3>(values_) = 0.0;
            std::get< 4>(values_) = 0;
            std::get< 5>(values_) = 0.0;
            std::get< 6>(values_) = 0.0;
            std::get< 7>(values_) = 0.0;
            std::get< 8>(values_) = 0.0;
            std::get< 9>(values_) = 0ul;
            std::get< 10>(values_) = 0ull;
            std::get< 11>(values_) = 0ull;
            std::get< 12>(values_) = 0ull;
            std::get< 13>(values_) = 0ull;
        }
        IDLGnssMeasurementsClock(const uint32_t &_flags, const int16_t &_leapSecond, const int64_t &_timeNs, const double &_timeUncertaintyNs, const int64_t &_fullBiasNs, const double &_biasNs, const double &_biasUncertaintyNs, const double &_driftNsps, const double &_driftUncertaintyNsps, const uint32_t &_hwClockDiscontinuityCount, const uint64_t &_elapsedRealTime, const uint64_t &_elapsedRealTimeUnc, const uint64_t &_elapsedgPTPTime, const uint64_t &_elapsedgPTPTimeUnc)
        {
            std::get< 0>(values_) = _flags;
            std::get< 1>(values_) = _leapSecond;
            std::get< 2>(values_) = _timeNs;
            std::get< 3>(values_) = _timeUncertaintyNs;
            std::get< 4>(values_) = _fullBiasNs;
            std::get< 5>(values_) = _biasNs;
            std::get< 6>(values_) = _biasUncertaintyNs;
            std::get< 7>(values_) = _driftNsps;
            std::get< 8>(values_) = _driftUncertaintyNsps;
            std::get< 9>(values_) = _hwClockDiscontinuityCount;
            std::get< 10>(values_) = _elapsedRealTime;
            std::get< 11>(values_) = _elapsedRealTimeUnc;
            std::get< 12>(values_) = _elapsedgPTPTime;
            std::get< 13>(values_) = _elapsedgPTPTimeUnc;
        }
        inline const uint32_t &getFlags() const { return std::get< 0>(values_); }
        inline void setFlags(const uint32_t &_value) { std::get< 0>(values_) = _value; }
        inline const int16_t &getLeapSecond() const { return std::get< 1>(values_); }
        inline void setLeapSecond(const int16_t &_value) { std::get< 1>(values_) = _value; }
        inline const int64_t &getTimeNs() const { return std::get< 2>(values_); }
        inline void setTimeNs(const int64_t &_value) { std::get< 2>(values_) = _value; }
        inline const double &getTimeUncertaintyNs() const { return std::get< 3>(values_); }
        inline void setTimeUncertaintyNs(const double &_value) { std::get< 3>(values_) = _value; }
        inline const int64_t &getFullBiasNs() const { return std::get< 4>(values_); }
        inline void setFullBiasNs(const int64_t &_value) { std::get< 4>(values_) = _value; }
        inline const double &getBiasNs() const { return std::get< 5>(values_); }
        inline void setBiasNs(const double &_value) { std::get< 5>(values_) = _value; }
        inline const double &getBiasUncertaintyNs() const { return std::get< 6>(values_); }
        inline void setBiasUncertaintyNs(const double &_value) { std::get< 6>(values_) = _value; }
        inline const double &getDriftNsps() const { return std::get< 7>(values_); }
        inline void setDriftNsps(const double &_value) { std::get< 7>(values_) = _value; }
        inline const double &getDriftUncertaintyNsps() const { return std::get< 8>(values_); }
        inline void setDriftUncertaintyNsps(const double &_value) { std::get< 8>(values_) = _value; }
        inline const uint32_t &getHwClockDiscontinuityCount() const { return std::get< 9>(values_); }
        inline void setHwClockDiscontinuityCount(const uint32_t &_value) { std::get< 9>(values_) = _value; }
        inline const uint64_t &getElapsedRealTime() const { return std::get< 10>(values_); }
        inline void setElapsedRealTime(const uint64_t &_value) { std::get< 10>(values_) = _value; }
        inline const uint64_t &getElapsedRealTimeUnc() const { return std::get< 11>(values_); }
        inline void setElapsedRealTimeUnc(const uint64_t &_value) { std::get< 11>(values_) = _value; }
        inline const uint64_t &getElapsedgPTPTime() const { return std::get< 12>(values_); }
        inline void setElapsedgPTPTime(const uint64_t &_value) { std::get< 12>(values_) = _value; }
        inline const uint64_t &getElapsedgPTPTimeUnc() const { return std::get< 13>(values_); }
        inline void setElapsedgPTPTimeUnc(const uint64_t &_value) { std::get< 13>(values_) = _value; }
        inline bool operator==(const IDLGnssMeasurementsClock& _other) const {
        return (getFlags() == _other.getFlags() && getLeapSecond() == _other.getLeapSecond() && getTimeNs() == _other.getTimeNs() && getTimeUncertaintyNs() == _other.getTimeUncertaintyNs() && getFullBiasNs() == _other.getFullBiasNs() && getBiasNs() == _other.getBiasNs() && getBiasUncertaintyNs() == _other.getBiasUncertaintyNs() && getDriftNsps() == _other.getDriftNsps() && getDriftUncertaintyNsps() == _other.getDriftUncertaintyNsps() && getHwClockDiscontinuityCount() == _other.getHwClockDiscontinuityCount() && getElapsedRealTime() == _other.getElapsedRealTime() && getElapsedRealTimeUnc() == _other.getElapsedRealTimeUnc() && getElapsedgPTPTime() == _other.getElapsedgPTPTime() && getElapsedgPTPTimeUnc() == _other.getElapsedgPTPTimeUnc());
        }
        inline bool operator!=(const IDLGnssMeasurementsClock &_other) const {
            return !((*this) == _other);
        }
    
    };
    struct IDLGnssMeasurements : CommonAPI::Struct< IDLGnssMeasurementsClock, std::vector< IDLGnssMeasurementsData >, bool, int16_t> {
    
        IDLGnssMeasurements()
        {
            std::get< 0>(values_) = IDLGnssMeasurementsClock();
            std::get< 1>(values_) = std::vector< IDLGnssMeasurementsData >();
            std::get< 2>(values_) = false;
            std::get< 3>(values_) = 0;
        }
        IDLGnssMeasurements(const IDLGnssMeasurementsClock &_clock, const std::vector< IDLGnssMeasurementsData > &_measurements, const bool &_isNHz, const int16_t &_reportingLatency)
        {
            std::get< 0>(values_) = _clock;
            std::get< 1>(values_) = _measurements;
            std::get< 2>(values_) = _isNHz;
            std::get< 3>(values_) = _reportingLatency;
        }
        inline const IDLGnssMeasurementsClock &getClock() const { return std::get< 0>(values_); }
        inline void setClock(const IDLGnssMeasurementsClock &_value) { std::get< 0>(values_) = _value; }
        inline const std::vector< IDLGnssMeasurementsData > &getMeasurements() const { return std::get< 1>(values_); }
        inline void setMeasurements(const std::vector< IDLGnssMeasurementsData > &_value) { std::get< 1>(values_) = _value; }
        inline const bool &getIsNHz() const { return std::get< 2>(values_); }
        inline void setIsNHz(const bool _value) { std::get< 2>(values_) = _value; }
        inline const int16_t &getReportingLatency() const { return std::get< 3>(values_); }
        inline void setReportingLatency(const int16_t &_value) { std::get< 3>(values_) = _value; }
        inline bool operator==(const IDLGnssMeasurements& _other) const {
        return (getClock() == _other.getClock() && getMeasurements() == _other.getMeasurements() && getIsNHz() == _other.getIsNHz() && getReportingLatency() == _other.getReportingLatency());
        }
        inline bool operator!=(const IDLGnssMeasurements &_other) const {
            return !((*this) == _other);
        }
    
    };
    
    struct IDLAidingDataDeletionMask : CommonAPI::Enumeration< uint32_t> {
        enum Literal : uint32_t {
            IDL_AIDING_DATA_DELETION_UNKNOWN = 0,
            IDL_AIDING_DATA_DELETION_ALL = 1,
            IDL_AIDING_DATA_DELETION_EPHEMERIS = 2,
            IDL_AIDING_DATA_DELETION_DR_SENSOR_CALIBRATION = 4
        };
    
        IDLAidingDataDeletionMask()
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_UNKNOWN)) {}
        IDLAidingDataDeletionMask(Literal _literal)
            : CommonAPI::Enumeration< uint32_t>(static_cast< uint32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_UNKNOWN):
                case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_ALL):
                case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_EPHEMERIS):
                case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_DR_SENSOR_CALIBRATION):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLAidingDataDeletionMask &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLAidingDataDeletionMask &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLAidingDataDeletionMask &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLAidingDataDeletionMask &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLAidingDataDeletionMask &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLAidingDataDeletionMask &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint32_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_UNKNOWN): return "IDL_AIDING_DATA_DELETION_UNKNOWN";
            case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_ALL): return "IDL_AIDING_DATA_DELETION_ALL";
            case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_EPHEMERIS): return "IDL_AIDING_DATA_DELETION_EPHEMERIS";
            case static_cast< uint32_t>(Literal::IDL_AIDING_DATA_DELETION_DR_SENSOR_CALIBRATION): return "IDL_AIDING_DATA_DELETION_DR_SENSOR_CALIBRATION";
            default: return "UNDEFINED";
            }
        }
    };
    
    struct IDLGnssConstellationType : CommonAPI::Enumeration< uint64_t> {
        enum Literal : uint64_t {
            IDL_GNSS_CONSTELLATION_TYPE_UNKNOWN = 0,
            IDL_GNSS_CONSTELLATION_TYPE_GLONASS = 1,
            IDL_GNSS_CONSTELLATION_TYPE_QZSS = 2,
            IDL_GNSS_CONSTELLATION_TYPE_BEIDOU = 3,
            IDL_GNSS_CONSTELLATION_TYPE_GALILEO = 4,
            IDL_GNSS_CONSTELLATION_TYPE_SBAS = 5,
            IDL_GNSS_CONSTELLATION_TYPE_NAVIC = 6,
            IDL_GNSS_CONSTELLATION_TYPE_GPS = 7,
            IDL_GNSS_CONSTELLATION_TYPE_MAX = 7
        };
    
        IDLGnssConstellationType()
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_UNKNOWN)) {}
        IDLGnssConstellationType(Literal _literal)
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_UNKNOWN):
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_GLONASS):
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_QZSS):
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_BEIDOU):
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_GALILEO):
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_SBAS):
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_NAVIC):
                case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_GPS):
                //case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_MAX):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const IDLGnssConstellationType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const IDLGnssConstellationType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const IDLGnssConstellationType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const IDLGnssConstellationType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const IDLGnssConstellationType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const IDLGnssConstellationType &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint64_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint64_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint64_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint64_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint64_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint64_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_UNKNOWN): return "IDL_GNSS_CONSTELLATION_TYPE_UNKNOWN";
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_GLONASS): return "IDL_GNSS_CONSTELLATION_TYPE_GLONASS";
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_QZSS): return "IDL_GNSS_CONSTELLATION_TYPE_QZSS";
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_BEIDOU): return "IDL_GNSS_CONSTELLATION_TYPE_BEIDOU";
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_GALILEO): return "IDL_GNSS_CONSTELLATION_TYPE_GALILEO";
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_SBAS): return "IDL_GNSS_CONSTELLATION_TYPE_SBAS";
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_NAVIC): return "IDL_GNSS_CONSTELLATION_TYPE_NAVIC";
            case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_GPS): return "IDL_GNSS_CONSTELLATION_TYPE_GPS";
            //case static_cast< uint64_t>(Literal::IDL_GNSS_CONSTELLATION_TYPE_MAX): return "IDL_GNSS_CONSTELLATION_TYPE_MAX";
            default: return "UNDEFINED";
            }
        }
    };
    struct IDLGnssSvIdInfo : CommonAPI::Struct< IDLGnssConstellationType, uint32_t> {
    
        IDLGnssSvIdInfo()
        {
            std::get< 0>(values_) = IDLGnssConstellationType();
            std::get< 1>(values_) = 0ul;
        }
        IDLGnssSvIdInfo(const IDLGnssConstellationType &_constellation, const uint32_t &_svId)
        {
            std::get< 0>(values_) = _constellation;
            std::get< 1>(values_) = _svId;
        }
        inline const IDLGnssConstellationType &getConstellation() const { return std::get< 0>(values_); }
        inline void setConstellation(const IDLGnssConstellationType &_value) { std::get< 0>(values_) = _value; }
        inline const uint32_t &getSvId() const { return std::get< 1>(values_); }
        inline void setSvId(const uint32_t &_value) { std::get< 1>(values_) = _value; }
        inline bool operator==(const IDLGnssSvIdInfo& _other) const {
        return (getConstellation() == _other.getConstellation() && getSvId() == _other.getSvId());
        }
        inline bool operator!=(const IDLGnssSvIdInfo &_other) const {
            return !((*this) == _other);
        }
    
    };
    
    struct MapMatchingFeedbackDataValidity : CommonAPI::Enumeration< uint64_t> {
        enum Literal : uint64_t {
            MMF_DATA_INVALID = 0,
            MMF_DATA_VALID_UTC_TIME = 1,
            MMF_DATA_VALID_LAT_DIFF = 2,
            MMF_DATA_VALID_LONG_DIFF = 4,
            MMF_DATA_VALID_TUNNEL = 8,
            MMF_DATA_VALID_BEARING = 16,
            MMF_DATA_VALID_ALTITUDE = 32,
            MMF_DATA_VALID_HOR_ACC = 64,
            MMF_DATA_VALID_ALT_ACC = 128,
            MMF_DATA_VALID_BEARING_ACC = 256
        };
    
        MapMatchingFeedbackDataValidity()
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(Literal::MMF_DATA_INVALID)) {}
        MapMatchingFeedbackDataValidity(Literal _literal)
            : CommonAPI::Enumeration< uint64_t>(static_cast< uint64_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast< uint64_t>(Literal::MMF_DATA_INVALID):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_UTC_TIME):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_LAT_DIFF):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_LONG_DIFF):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_TUNNEL):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_BEARING):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_ALTITUDE):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_HOR_ACC):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_ALT_ACC):
                case static_cast< uint64_t>(Literal::MMF_DATA_VALID_BEARING_ACC):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapMatchingFeedbackDataValidity &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapMatchingFeedbackDataValidity &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapMatchingFeedbackDataValidity &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapMatchingFeedbackDataValidity &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapMatchingFeedbackDataValidity &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapMatchingFeedbackDataValidity &_other) const { return (value_ > _other.value_); }
    
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast< uint64_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast< uint64_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast< uint64_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast< uint64_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast< uint64_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast< uint64_t>(_value)); }
    
        const char* toString() const noexcept
        {
            switch(value_)
            {
            case static_cast< uint64_t>(Literal::MMF_DATA_INVALID): return "MMF_DATA_INVALID";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_UTC_TIME): return "MMF_DATA_VALID_UTC_TIME";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_LAT_DIFF): return "MMF_DATA_VALID_LAT_DIFF";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_LONG_DIFF): return "MMF_DATA_VALID_LONG_DIFF";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_TUNNEL): return "MMF_DATA_VALID_TUNNEL";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_BEARING): return "MMF_DATA_VALID_BEARING";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_ALTITUDE): return "MMF_DATA_VALID_ALTITUDE";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_HOR_ACC): return "MMF_DATA_VALID_HOR_ACC";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_ALT_ACC): return "MMF_DATA_VALID_ALT_ACC";
            case static_cast< uint64_t>(Literal::MMF_DATA_VALID_BEARING_ACC): return "MMF_DATA_VALID_BEARING_ACC";
            default: return "UNDEFINED";
            }
        }
    };
    struct MapMatchingFeedbackData : CommonAPI::Struct< uint64_t, uint64_t, double, double, float, double, float, float, float, bool> {
    
        MapMatchingFeedbackData()
        {
            std::get< 0>(values_) = 0ull;
            std::get< 1>(values_) = 0ull;
            std::get< 2>(values_) = 0.0;
            std::get< 3>(values_) = 0.0;
            std::get< 4>(values_) = 0.0f;
            std::get< 5>(values_) = 0.0;
            std::get< 6>(values_) = 0.0f;
            std::get< 7>(values_) = 0.0f;
            std::get< 8>(values_) = 0.0f;
            std::get< 9>(values_) = false;
        }
        MapMatchingFeedbackData(const uint64_t &_validityMask, const uint64_t &_utcTimestampMs, const double &_mapMatchedLatitudeDifference, const double &_mapMatchedLongitudeDifference, const float &_bearing, const double &_altitude, const float &_horizontalAccuracy, const float &_altitudeAccuracy, const float &_bearingAccuracy, const bool &_isTunnel)
        {
            std::get< 0>(values_) = _validityMask;
            std::get< 1>(values_) = _utcTimestampMs;
            std::get< 2>(values_) = _mapMatchedLatitudeDifference;
            std::get< 3>(values_) = _mapMatchedLongitudeDifference;
            std::get< 4>(values_) = _bearing;
            std::get< 5>(values_) = _altitude;
            std::get< 6>(values_) = _horizontalAccuracy;
            std::get< 7>(values_) = _altitudeAccuracy;
            std::get< 8>(values_) = _bearingAccuracy;
            std::get< 9>(values_) = _isTunnel;
        }
        inline const uint64_t &getValidityMask() const { return std::get< 0>(values_); }
        inline void setValidityMask(const uint64_t &_value) { std::get< 0>(values_) = _value; }
        inline const uint64_t &getUtcTimestampMs() const { return std::get< 1>(values_); }
        inline void setUtcTimestampMs(const uint64_t &_value) { std::get< 1>(values_) = _value; }
        inline const double &getMapMatchedLatitudeDifference() const { return std::get< 2>(values_); }
        inline void setMapMatchedLatitudeDifference(const double &_value) { std::get< 2>(values_) = _value; }
        inline const double &getMapMatchedLongitudeDifference() const { return std::get< 3>(values_); }
        inline void setMapMatchedLongitudeDifference(const double &_value) { std::get< 3>(values_) = _value; }
        inline const float &getBearing() const { return std::get< 4>(values_); }
        inline void setBearing(const float &_value) { std::get< 4>(values_) = _value; }
        inline const double &getAltitude() const { return std::get< 5>(values_); }
        inline void setAltitude(const double &_value) { std::get< 5>(values_) = _value; }
        inline const float &getHorizontalAccuracy() const { return std::get< 6>(values_); }
        inline void setHorizontalAccuracy(const float &_value) { std::get< 6>(values_) = _value; }
        inline const float &getAltitudeAccuracy() const { return std::get< 7>(values_); }
        inline void setAltitudeAccuracy(const float &_value) { std::get< 7>(values_) = _value; }
        inline const float &getBearingAccuracy() const { return std::get< 8>(values_); }
        inline void setBearingAccuracy(const float &_value) { std::get< 8>(values_) = _value; }
        inline const bool &getIsTunnel() const { return std::get< 9>(values_); }
        inline void setIsTunnel(const bool _value) { std::get< 9>(values_) = _value; }
        inline bool operator==(const MapMatchingFeedbackData& _other) const {
        return (getValidityMask() == _other.getValidityMask() && getUtcTimestampMs() == _other.getUtcTimestampMs() && getMapMatchedLatitudeDifference() == _other.getMapMatchedLatitudeDifference() && getMapMatchedLongitudeDifference() == _other.getMapMatchedLongitudeDifference() && getBearing() == _other.getBearing() && getAltitude() == _other.getAltitude() && getHorizontalAccuracy() == _other.getHorizontalAccuracy() && getAltitudeAccuracy() == _other.getAltitudeAccuracy() && getBearingAccuracy() == _other.getBearingAccuracy() && getIsTunnel() == _other.getIsTunnel());
        }
        inline bool operator!=(const MapMatchingFeedbackData &_other) const {
            return !((*this) == _other);
        }
    
    };
};

const char* LocIdlAPI::getInterface() {
    return ("com.qualcomm.qti.location.LocIdlAPI:v0_2");
}

CommonAPI::Version LocIdlAPI::getInterfaceVersion() {
    return CommonAPI::Version(0, 2);
}


} // namespace location
} // namespace qti
} // namespace qualcomm
} // namespace com
} // namespace v0

namespace CommonAPI {
}


// Compatibility
namespace v0_2 = v0;

#endif // V0_COM_QUALCOMM_QTI_LOCATION_LOC_IDL_API_HPP_
